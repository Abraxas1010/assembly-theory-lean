window.ASSEMBLY_PROOFS = {"meta": {"generatedAt": "2026-01-09T17:15:37.393190Z", "seed": "assembly-theory-umap-v1", "source": "RESEARCHER_BUNDLE/HeytingLean/ATheory", "notes": "UMAP embedding of Assembly Theory declarations (edges = kNN in feature space)."}, "items": [{"id": "HeytingLean.ATheory.Alphabet", "name": "HeytingLean.ATheory.Alphabet", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 25, "family": "Core", "snippet": "structure Alphabet (α : Type u) where\n  basis : Finset α\n\n/-- Binary assembly rule set: given two parts, return the finite set of\nadmissible composites. -/\nstructure Rules (α : Type u) where", "pos": {"x": 0.8260658979415894, "y": 0.8584365248680115}, "pos3": {"x": 0.879287600517273, "y": 0.22552698850631714, "z": 0.28732410073280334}}, {"id": "HeytingLean.ATheory.Rules", "name": "HeytingLean.ATheory.Rules", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 30, "family": "Core", "snippet": "structure Rules (α : Type u) where\n  compose : α → α → Finset α\n\n/-- Abstract syntax of assembly objects built from primitive parts. -/\ninductive Obj (α : Type u) where\n  | base : α → Obj α", "pos": {"x": 0.805060863494873, "y": 0.8512724041938782}, "pos3": {"x": 0.8816093802452087, "y": 0.18911045789718628, "z": 0.25435906648635864}}, {"id": "HeytingLean.ATheory.Obj", "name": "HeytingLean.ATheory.Obj", "kind": "inductive", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 34, "family": "Core", "snippet": "inductive Obj (α : Type u) where\n  | base : α → Obj α\n  | join : Obj α → Obj α → Obj α\nderiving Repr, DecidableEq\n\nnamespace Obj", "pos": {"x": 0.9765324592590332, "y": 0.9748541712760925}, "pos3": {"x": 0.9801324009895325, "y": 0.34574708342552185, "z": 0.06612634658813477}}, {"id": "HeytingLean.ATheory.Obj.subobjects", "name": "HeytingLean.ATheory.Obj.subobjects", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 47, "family": "Core", "snippet": "def subobjects [DecidableEq α] : Obj α → Finset (Obj α)\n  | base a => {base a}\n  | join x y => insert (join x y) (subobjects x ∪ subobjects y)\n\n/-- Predicate: the object is a `join` node. -/\ndef isJoin : Obj α → Bool", "pos": {"x": 0.7200820446014404, "y": 0.7830683588981628}, "pos3": {"x": 0.8021532893180847, "y": 0.2599283754825592, "z": 0.43340587615966797}}, {"id": "HeytingLean.ATheory.Obj.isJoin", "name": "HeytingLean.ATheory.Obj.isJoin", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 52, "family": "Core", "snippet": "def isJoin : Obj α → Bool\n  | base _ => false\n  | join _ _ => true\n\nlemma isJoin_iff {o : Obj α} : isJoin o = true ↔ (∃ x y, o = join x y) := by\n  cases o <;> simp [isJoin]", "pos": {"x": 0.8979927897453308, "y": 0.9329740405082703}, "pos3": {"x": 0.9234142303466797, "y": 0.2216431200504303, "z": 0.16656862199306488}}, {"id": "HeytingLean.ATheory.Obj.isJoin_iff", "name": "HeytingLean.ATheory.Obj.isJoin_iff", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 56, "family": "Core", "snippet": "lemma isJoin_iff {o : Obj α} : isJoin o = true ↔ (∃ x y, o = join x y) := by\n  cases o <;> simp [isJoin]\n\n/-- Count the number of join-nodes in an object as a simple structural size\nmeasure. This is a fallback notion of length when no explicit path is given. -/\ndef joinCount : Obj α → Nat", "pos": {"x": 0.2435554563999176, "y": 0.31647664308547974}, "pos3": {"x": 0.3241923451423645, "y": 0.7203863263130188, "z": 0.9787936806678772}}, {"id": "HeytingLean.ATheory.Obj.joinCount", "name": "HeytingLean.ATheory.Obj.joinCount", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 61, "family": "Core", "snippet": "def joinCount : Obj α → Nat\n  | base _    => 0\n  | join x y  => joinCount x + joinCount y + 1\n\n/-- Reuse-aware join count: count the number of *distinct* `join` subobjects.", "pos": {"x": 0.9052044153213501, "y": 0.9154694080352783}, "pos3": {"x": 0.9376643300056458, "y": 0.2653687298297882, "z": 0.16388198733329773}}, {"id": "HeytingLean.ATheory.Obj.dagJoinCount", "name": "HeytingLean.ATheory.Obj.dagJoinCount", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 73, "family": "Core", "snippet": "def dagJoinCount [DecidableEq α] (o : Obj α) : Nat :=\n  ((subobjects o).filter (fun t => isJoin t)).card\n\ntheorem dagJoinCount_le_joinCount [DecidableEq α] (o : Obj α) :\n    dagJoinCount o ≤ joinCount o := by\n  classical", "pos": {"x": 0.6715436577796936, "y": 0.7288367748260498}, "pos3": {"x": 0.7596963047981262, "y": 0.32541418075561523, "z": 0.4775347113609314}}, {"id": "HeytingLean.ATheory.Obj.dagJoinCount_le_joinCount", "name": "HeytingLean.ATheory.Obj.dagJoinCount_le_joinCount", "kind": "theorem", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 76, "family": "Core", "snippet": "theorem dagJoinCount_le_joinCount [DecidableEq α] (o : Obj α) :\n    dagJoinCount o ≤ joinCount o := by\n  classical\n  induction o with\n  | base a =>\n      simp [dagJoinCount, subobjects, isJoin, joinCount]", "pos": {"x": 0.7288840413093567, "y": 0.8576762080192566}, "pos3": {"x": 0.8379310369491577, "y": 0.13212449848651886, "z": 0.41128286719322205}}, {"id": "HeytingLean.ATheory.Path", "name": "HeytingLean.ATheory.Path", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 146, "family": "Core", "snippet": "structure Path (α : Type u) (R : Rules α) (target : Obj α) where\n  nodes : List (Obj α)\n  /-- For every adjacent pair `p, q` in the node list, there are primitive\n  parts `a, b` and a composite `c` such that `p` is the join of the bases\n  of `a` and `b`, `q` is the base of `c`, and `c` appears in `R.compose a b`. -/\n  wellFormed :", "pos": {"x": 0.08289355784654617, "y": 0.16357477009296417}, "pos3": {"x": 0.11308686435222626, "y": 0.8434731960296631, "z": 0.9294824600219727}}, {"id": "HeytingLean.ATheory.Path.trivial", "name": "HeytingLean.ATheory.Path.trivial", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 166, "family": "Core", "snippet": "def trivial (o : Obj α) : Path α R o where\n  nodes := [o]\n  wellFormed := by\n    intro p q hmem\n    -- There are no adjacent pairs in a singleton list.\n    simp [List.zip, List.tail] at hmem", "pos": {"x": 0.8266934156417847, "y": 0.8876416683197021}, "pos3": {"x": 0.8934633731842041, "y": 0.24458810687065125, "z": 0.2675511837005615}}, {"id": "HeytingLean.ATheory.Path.trivial_len", "name": "HeytingLean.ATheory.Path.trivial_len", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 173, "family": "Core", "snippet": "@[simp] lemma trivial_len (o : Obj α) :\n    (trivial (R := R) o).len = 1 := rfl\n\nend Path\n\n/-- Canonical assembly path for an object, built purely from its syntax.", "pos": {"x": 0.9283893704414368, "y": 0.9655824899673462}, "pos3": {"x": 0.95709228515625, "y": 0.24723492562770844, "z": 0.09895354509353638}}, {"id": "HeytingLean.ATheory.canonicalPath", "name": "HeytingLean.ATheory.canonicalPath", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 183, "family": "Core", "snippet": "def canonicalPath {α : Type u} [DecidableEq α] (R : Rules α) (o : Obj α) : Path α R o where\n  nodes := [o]\n  wellFormed := by\n    intro p q hmem\n    -- As in `trivial`, there are no adjacent pairs in a singleton list.\n    simp [List.zip, List.tail] at hmem", "pos": {"x": 0.49394211173057556, "y": 0.5626370906829834}, "pos3": {"x": 0.5914465188980103, "y": 0.45615363121032715, "z": 0.6992175579071045}}, {"id": "HeytingLean.ATheory.assemblyIndex", "name": "HeytingLean.ATheory.assemblyIndex", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 195, "family": "Core", "snippet": "def assemblyIndex {α : Type u} [DecidableEq α] (R : Rules α) (o : Obj α) : Nat :=\n  (canonicalPath (R := R) o).len\n\n/-- Alias exposing the assembly index as the “birth-time” of an object in the\nAssembly Theory layer. -/\ndef birthAT {α : Type u} [DecidableEq α] (R : Rules α) (o : Obj α) : Nat :=", "pos": {"x": 0.23104023933410645, "y": 0.29072055220603943}, "pos3": {"x": 0.31258755922317505, "y": 0.7351193428039551, "z": 0.9871193170547485}}, {"id": "HeytingLean.ATheory.birthAT", "name": "HeytingLean.ATheory.birthAT", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/AssemblyCore.lean", "line": 200, "family": "Core", "snippet": "def birthAT {α : Type u} [DecidableEq α] (R : Rules α) (o : Obj α) : Nat :=\n  assemblyIndex R o\n\nend ATheory\nend HeytingLean", "pos": {"x": 0.9700451493263245, "y": 0.9750950932502747}, "pos3": {"x": 0.9698874354362488, "y": 0.29623788595199585, "z": 0.030793266370892525}}, {"id": "HeytingLean.ATheory.CopyNumber", "name": "HeytingLean.ATheory.CopyNumber", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 28, "family": "Selection", "snippet": "structure CopyNumber (V : Type u) where\n  /-- Raw counts for each object. -/\n  n : V → Nat\n  /-- A secondary weight or normalized proxy (e.g. coarse-grained copy number). -/\n  μ : V → Nat", "pos": {"x": 0.8403220176696777, "y": 0.8644986748695374}, "pos3": {"x": 0.8905895352363586, "y": 0.24135060608386993, "z": 0.23663441836833954}}, {"id": "HeytingLean.ATheory.nullTail", "name": "HeytingLean.ATheory.nullTail", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 39, "family": "Selection", "snippet": "noncomputable def nullTail (θ : Nat) : ℝ :=\n  1 / (θ.succ : ℝ)\n\n/-- Assembly functional combining assembly index and copy number. For an object\n`v` with index `idx v` and discrete weight `μ v`, we define", "pos": {"x": 0.7980062961578369, "y": 0.8120744228363037}, "pos3": {"x": 0.8519484996795654, "y": 0.28324785828590393, "z": 0.3229217231273651}}, {"id": "HeytingLean.ATheory.Assembly", "name": "HeytingLean.ATheory.Assembly", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 49, "family": "Selection", "snippet": "noncomputable def Assembly (idx : V → Nat) (μ : V → Nat) (v : V) : ℝ :=\n  (μ v : ℝ) * (idx v + 1 : ℝ)\n\nnamespace Assembly\n\nvariable (idx : V → Nat) (μ : V → Nat)", "pos": {"x": 0.9418240189552307, "y": 0.9670177698135376}, "pos3": {"x": 0.948280394077301, "y": 0.3025874197483063, "z": 0.05379435792565346}}, {"id": "HeytingLean.ATheory.Assembly.monotone_in_mu", "name": "HeytingLean.ATheory.Assembly.monotone_in_mu", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 57, "family": "Selection", "snippet": "lemma monotone_in_mu {v : V} {μ₁ μ₂ : V → Nat}\n    (hμ : μ₁ v ≤ μ₂ v) :\n    Assembly idx μ₁ v ≤ Assembly idx μ₂ v := by\n  unfold Assembly\n  have hcoe : (μ₁ v : ℝ) ≤ (μ₂ v : ℝ) := by exact_mod_cast hμ\n  have hden : 0 ≤ (idx v + 1 : ℝ) := by", "pos": {"x": 0.5247450470924377, "y": 0.6321340799331665}, "pos3": {"x": 0.6395057439804077, "y": 0.35157349705696106, "z": 0.6304785013198853}}, {"id": "HeytingLean.ATheory.Assembly.monotone_in_idx", "name": "HeytingLean.ATheory.Assembly.monotone_in_idx", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 67, "family": "Selection", "snippet": "lemma monotone_in_idx {v : V} {idx₁ idx₂ : V → Nat}\n    (hidx : idx₁ v ≤ idx₂ v) :\n    Assembly idx₁ μ v ≤ Assembly idx₂ μ v := by\n  unfold Assembly\n  have hμnonneg : 0 ≤ (μ v : ℝ) := by\n    exact_mod_cast (Nat.zero_le (μ v))", "pos": {"x": 0.6205862760543823, "y": 0.7012079358100891}, "pos3": {"x": 0.7157601714134216, "y": 0.2815665304660797, "z": 0.5360599756240845}}, {"id": "HeytingLean.ATheory.selected", "name": "HeytingLean.ATheory.selected", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 81, "family": "Selection", "snippet": "def selected (Θ : Nat) (τ : Nat) (vset : Finset V)\n    (idx : V → Nat) (μ : V → Nat) : Prop :=\n  ∃ v ∈ vset, idx v ≥ Θ ∧ μ v ≥ τ\n\nnamespace selected", "pos": {"x": 0.9613509774208069, "y": 0.9630935192108154}, "pos3": {"x": 0.9671245813369751, "y": 0.2172943353652954, "z": 0.06234589219093323}}, {"id": "HeytingLean.ATheory.selected.mono_in_Theta", "name": "HeytingLean.ATheory.selected.mono_in_Theta", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 92, "family": "Selection", "snippet": "lemma mono_in_Theta (hΘ : Θ' ≤ Θ)\n    (hsel : selected Θ τ vset idx μ) :\n    selected Θ' τ vset idx μ := by\n  rcases hsel with ⟨v, hvset, hidx, hμ⟩\n  refine ⟨v, hvset, ?_, hμ⟩\n  exact le_trans hΘ hidx", "pos": {"x": 0.7816786170005798, "y": 0.8597326278686523}, "pos3": {"x": 0.8621736168861389, "y": 0.1723044365644455, "z": 0.3352415859699249}}, {"id": "HeytingLean.ATheory.selected.mono_in_tau", "name": "HeytingLean.ATheory.selected.mono_in_tau", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 101, "family": "Selection", "snippet": "lemma mono_in_tau (hτ : τ' ≤ τ)\n    (hsel : selected Θ τ vset idx μ) :\n    selected Θ τ' vset idx μ := by\n  rcases hsel with ⟨v, hvset, hidx, hμ⟩\n  refine ⟨v, hvset, hidx, ?_⟩\n  exact le_trans hτ hμ", "pos": {"x": 0.7922245860099792, "y": 0.865888774394989}, "pos3": {"x": 0.872183084487915, "y": 0.2853772044181824, "z": 0.3515785038471222}}, {"id": "HeytingLean.ATheory.AssemblyEnsemble", "name": "HeytingLean.ATheory.AssemblyEnsemble", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 116, "family": "Selection", "snippet": "noncomputable def AssemblyEnsemble (idx : V → Nat) (n : V → Nat)\n    (vset : Finset V) : ℝ :=\n  -- Total copy number as a natural\n  let NTn : Nat := vset.sum (fun v => n v)\n  -- Guard against the degenerate ensemble: `N_T = 0`\n  if NTn = 0 then", "pos": {"x": 0.5232131481170654, "y": 0.6217288374900818}, "pos3": {"x": 0.619357705116272, "y": 0.3948395252227783, "z": 0.6689956188201904}}, {"id": "HeytingLean.ATheory.AssemblyEnsemble_empty", "name": "HeytingLean.ATheory.AssemblyEnsemble_empty", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 130, "family": "Selection", "snippet": "lemma AssemblyEnsemble_empty [DecidableEq V] (idx : V → Nat) (n : V → Nat) :\n    AssemblyEnsemble idx n (∅ : Finset V) = 0 := by\n  -- By definition `NTn = ∑ v in ∅, n v = 0`\n  simp [AssemblyEnsemble]\n\nlemma AssemblyEnsemble_zero_total [DecidableEq V]", "pos": {"x": 0.502810001373291, "y": 0.5998427867889404}, "pos3": {"x": 0.5968077778816223, "y": 0.4525691568851471, "z": 0.6543352007865906}}, {"id": "HeytingLean.ATheory.AssemblyEnsemble_zero_total", "name": "HeytingLean.ATheory.AssemblyEnsemble_zero_total", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/CopyNumberSelection.lean", "line": 135, "family": "Selection", "snippet": "lemma AssemblyEnsemble_zero_total [DecidableEq V]\n    (idx : V → Nat) (n : V → Nat) (vset : Finset V)\n    (h : vset.sum (fun v => n v) = 0) :\n    AssemblyEnsemble idx n vset = 0 := by\n  -- The guard condition triggers when the total copy number is zero\n  simp [AssemblyEnsemble, h]", "pos": {"x": 0.2753393054008484, "y": 0.3469915986061096}, "pos3": {"x": 0.3497021198272705, "y": 0.669514000415802, "z": 0.9244557023048401}}, {"id": "HeytingLean.ATheory.Obj.size", "name": "HeytingLean.ATheory.Obj.size", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 13, "family": "Bounds", "snippet": "def size : Obj α → Nat\n  | Obj.base _ => 1\n  | Obj.join l r => size l + size r\n\n@[simp] lemma size_base (a : α) : size (Obj.base a) = 1 := rfl", "pos": {"x": 0.9828319549560547, "y": 0.9289381504058838}, "pos3": {"x": 0.967797577381134, "y": 0.2207314372062683, "z": 0.03468471020460129}}, {"id": "HeytingLean.ATheory.Obj.size_base", "name": "HeytingLean.ATheory.Obj.size_base", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 17, "family": "Bounds", "snippet": "@[simp] lemma size_base (a : α) : size (Obj.base a) = 1 := rfl\n\n@[simp] lemma size_join (l r : Obj α) : size (Obj.join l r) = size l + size r := rfl\n\nlemma size_pos (o : Obj α) : 0 < size o := by\n  induction o with", "pos": {"x": 0.7377259731292725, "y": 0.7777964472770691}, "pos3": {"x": 0.8167926073074341, "y": 0.3210453689098358, "z": 0.4058896005153656}}, {"id": "HeytingLean.ATheory.Obj.size_join", "name": "HeytingLean.ATheory.Obj.size_join", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 19, "family": "Bounds", "snippet": "@[simp] lemma size_join (l r : Obj α) : size (Obj.join l r) = size l + size r := rfl\n\nlemma size_pos (o : Obj α) : 0 < size o := by\n  induction o with\n  | base a => simp\n  | join l r ihl ihr =>", "pos": {"x": 0.8219835758209229, "y": 0.8801825642585754}, "pos3": {"x": 0.8742875456809998, "y": 0.23776113986968994, "z": 0.2841026186943054}}, {"id": "HeytingLean.ATheory.Obj.size_pos", "name": "HeytingLean.ATheory.Obj.size_pos", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 21, "family": "Bounds", "snippet": "lemma size_pos (o : Obj α) : 0 < size o := by\n  induction o with\n  | base a => simp\n  | join l r ihl ihr =>\n      simpa [size] using Nat.add_pos_left ihl (size r)", "pos": {"x": 0.9231310486793518, "y": 0.9419058561325073}, "pos3": {"x": 0.9457170367240906, "y": 0.31060484051704407, "z": 0.09706812351942062}}, {"id": "HeytingLean.ATheory.Obj.size_eq_joinCount_add_one", "name": "HeytingLean.ATheory.Obj.size_eq_joinCount_add_one", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 27, "family": "Bounds", "snippet": "lemma size_eq_joinCount_add_one (o : Obj α) : size o = Obj.joinCount o + 1 := by\n  induction o with\n  | base a => simp [size, Obj.joinCount]\n  | join l r ihl ihr =>\n      calc\n        size (Obj.join l r) = size l + size r := by simp [size]", "pos": {"x": 0.5128865838050842, "y": 0.6360196471214294}, "pos3": {"x": 0.6130020618438721, "y": 0.36591073870658875, "z": 0.588881254196167}}, {"id": "HeytingLean.ATheory.Paper.AssemblyBounds.assemblyIndex_le_size_sub_one", "name": "HeytingLean.ATheory.Paper.AssemblyBounds.assemblyIndex_le_size_sub_one", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 63, "family": "Bounds", "snippet": "lemma assemblyIndex_le_size_sub_one [DecidableEq α] (o : Obj α) :\n    AssemblySpace.AssemblyIndex.assemblyIndex\n        (S := ObjSyntax.space (Atom := α))\n        (hC := ObjSyntax.space.closed (Atom := α)) o\n      ≤ Obj.size o - 1 := by\n  have hle :", "pos": {"x": 0.38489851355552673, "y": 0.5837222933769226}, "pos3": {"x": 0.5072180032730103, "y": 0.44625309109687805, "z": 0.6219931840896606}}, {"id": "HeytingLean.ATheory.Paper.AssemblyBounds.ObjSyntax.size_le_mul_pow_two_availableAfter", "name": "HeytingLean.ATheory.Paper.AssemblyBounds.ObjSyntax.size_le_mul_pow_two_availableAfter", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 87, "family": "Bounds", "snippet": "private lemma size_le_mul_pow_two_availableAfter\n    (A : Set (Obj α)) (M : Nat) :\n    ∀ (steps : List (Step (ObjSyntax.space (Atom := α)))),\n      (∀ t, t ∈ A → Obj.size t ≤ M) →\n      WellFormedFrom (S := ObjSyntax.space (Atom := α)) A steps →\n      ∀ t, t ∈ availableAfter (S := ObjSyntax.space (Atom := α)) A steps →", "pos": {"x": 0.05756991356611252, "y": 0.25964102149009705}, "pos3": {"x": 0.15110163390636444, "y": 0.7324387431144714, "z": 0.8686210513114929}}, {"id": "HeytingLean.ATheory.Paper.AssemblyBounds.ObjSyntax.size_le_pow_two_availableAfterU", "name": "HeytingLean.ATheory.Paper.AssemblyBounds.ObjSyntax.size_le_pow_two_availableAfterU", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 129, "family": "Bounds", "snippet": "private lemma size_le_pow_two_availableAfterU :\n    ∀ (steps : List (Step (ObjSyntax.space (Atom := α)))),\n      WellFormedFrom (S := ObjSyntax.space (Atom := α)) (ObjSyntax.space (Atom := α)).U steps →\n      ∀ t, t ∈ availableAfter (S := ObjSyntax.space (Atom := α)) (ObjSyntax.space (Atom := α)).U steps →\n        Obj.size t ≤ 2 ^ steps.length := by\n  intro steps hWF t ht", "pos": {"x": 0.018157757818698883, "y": 0.042135465890169144}, "pos3": {"x": 0.020020591095089912, "y": 0.9926902651786804, "z": 0.9177798628807068}}, {"id": "HeytingLean.ATheory.Paper.AssemblyBounds.assemblyIndex_ge_log2", "name": "HeytingLean.ATheory.Paper.AssemblyBounds.assemblyIndex_ge_log2", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 145, "family": "Bounds", "snippet": "lemma assemblyIndex_ge_log2 [DecidableEq α] (o : Obj α) (ho : Obj.size o > 1) :\n    Nat.log 2 (Obj.size o)\n      ≤\n      AssemblySpace.AssemblyIndex.assemblyIndex\n        (S := ObjSyntax.space (Atom := α))\n        (hC := ObjSyntax.space.closed (Atom := α)) o := by", "pos": {"x": 0.33679699897766113, "y": 0.503004789352417}, "pos3": {"x": 0.43167805671691895, "y": 0.5593327283859253, "z": 0.7326708436012268}}, {"id": "HeytingLean.ATheory.Paper.AssemblyBounds.dagJoinCount_bounds", "name": "HeytingLean.ATheory.Paper.AssemblyBounds.dagJoinCount_bounds", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 183, "family": "Bounds", "snippet": "lemma dagJoinCount_bounds [DecidableEq α] (o : Obj α) (ho : Obj.size o > 1) :\n    Nat.log 2 (Obj.size o) ≤ Obj.dagJoinCount o ∧ Obj.dagJoinCount o ≤ Obj.size o - 1 := by\n  have hlog :\n      Nat.log 2 (Obj.size o)\n        ≤\n        AssemblySpace.AssemblyIndex.assemblyIndex", "pos": {"x": 0.28116944432258606, "y": 0.4314165413379669}, "pos3": {"x": 0.3844885230064392, "y": 0.6159802079200745, "z": 0.8099303245544434}}, {"id": "HeytingLean.ATheory.Paper.AssemblyBounds.greedyIndex", "name": "HeytingLean.ATheory.Paper.AssemblyBounds.greedyIndex", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 206, "family": "Bounds", "snippet": "noncomputable def greedyIndex [DecidableEq α] (o : Obj α) : Nat :=\n  Obj.dagJoinCount o\n\nlemma greedyIndex_ge_assemblyIndex [DecidableEq α] (o : Obj α) :\n    AssemblySpace.AssemblyIndex.assemblyIndex\n        (S := ObjSyntax.space (Atom := α))", "pos": {"x": 0.48356157541275024, "y": 0.6150895357131958}, "pos3": {"x": 0.5923904180526733, "y": 0.38611316680908203, "z": 0.6165295839309692}}, {"id": "HeytingLean.ATheory.Paper.AssemblyBounds.greedyIndex_ge_assemblyIndex", "name": "HeytingLean.ATheory.Paper.AssemblyBounds.greedyIndex_ge_assemblyIndex", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyBounds.lean", "line": 209, "family": "Bounds", "snippet": "lemma greedyIndex_ge_assemblyIndex [DecidableEq α] (o : Obj α) :\n    AssemblySpace.AssemblyIndex.assemblyIndex\n        (S := ObjSyntax.space (Atom := α))\n        (hC := ObjSyntax.space.closed (Atom := α)) o\n      ≤ greedyIndex (α := α) o := by\n  simp [greedyIndex, ObjSyntax.space.assemblyIndex_eq_dagJoinCount (Atom := α) (o := o)]", "pos": {"x": 0.03665870055556297, "y": 0.10310833156108856}, "pos3": {"x": 0.07187753915786743, "y": 0.8784371018409729, "z": 0.9211032390594482}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.HasPathLen", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.HasPathLen", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 18, "family": "Index", "snippet": "def HasPathLen (z : S.Ω) (n : Nat) : Prop :=\n  ∃ p : AssemblyPath (S := S) z, p.len = n\n\nlemma exists_len_of_closed (hC : Closed S) (z : S.Ω) :\n    ∃ n : Nat, HasPathLen (S := S) z n := by\n  rcases hC.exists_path z with ⟨p⟩", "pos": {"x": 0.600559413433075, "y": 0.7714670300483704}, "pos3": {"x": 0.713843584060669, "y": 0.08845144510269165, "z": 0.47623535990715027}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.exists_len_of_closed", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.exists_len_of_closed", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 21, "family": "Index", "snippet": "lemma exists_len_of_closed (hC : Closed S) (z : S.Ω) :\n    ∃ n : Nat, HasPathLen (S := S) z n := by\n  rcases hC.exists_path z with ⟨p⟩\n  refine ⟨p.len, p, rfl⟩\n\nnoncomputable def assemblyIndex (hC : Closed S) (z : S.Ω) : Nat :=", "pos": {"x": 0.5716753602027893, "y": 0.7535057067871094}, "pos3": {"x": 0.7029742002487183, "y": 0.10823935270309448, "z": 0.5237095355987549}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 26, "family": "Index", "snippet": "noncomputable def assemblyIndex (hC : Closed S) (z : S.Ω) : Nat :=\n  Nat.find (exists_len_of_closed (S := S) hC z)\n\nlemma assemblyIndex_spec (hC : Closed S) (z : S.Ω) :\n    HasPathLen (S := S) z (assemblyIndex (S := S) hC z) :=\n  Nat.find_spec (exists_len_of_closed (S := S) hC z)", "pos": {"x": 0.2253042608499527, "y": 0.4256569445133209}, "pos3": {"x": 0.3400239646434784, "y": 0.6529839634895325, "z": 0.7668505907058716}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_spec", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_spec", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 29, "family": "Index", "snippet": "lemma assemblyIndex_spec (hC : Closed S) (z : S.Ω) :\n    HasPathLen (S := S) z (assemblyIndex (S := S) hC z) :=\n  Nat.find_spec (exists_len_of_closed (S := S) hC z)\n\nlemma assemblyIndex_le_of_hasLen (hC : Closed S) (z : S.Ω) {n : Nat}\n    (hn : HasPathLen (S := S) z n) :", "pos": {"x": 0.3042190968990326, "y": 0.5129180550575256}, "pos3": {"x": 0.4025226831436157, "y": 0.6076245903968811, "z": 0.6951140761375427}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_le_of_hasLen", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_le_of_hasLen", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 33, "family": "Index", "snippet": "lemma assemblyIndex_le_of_hasLen (hC : Closed S) (z : S.Ω) {n : Nat}\n    (hn : HasPathLen (S := S) z n) :\n    assemblyIndex (S := S) hC z ≤ n :=\n  Nat.find_min' (exists_len_of_closed (S := S) hC z) hn\n\nlemma assemblyIndex_le_of_path (hC : Closed S) {z : S.Ω} (p : AssemblyPath (S := S) z) :", "pos": {"x": 0.1623106300830841, "y": 0.37797990441322327}, "pos3": {"x": 0.276170015335083, "y": 0.6773164868354797, "z": 0.7754529714584351}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_le_of_path", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_le_of_path", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 38, "family": "Index", "snippet": "lemma assemblyIndex_le_of_path (hC : Closed S) {z : S.Ω} (p : AssemblyPath (S := S) z) :\n    assemblyIndex (S := S) hC z ≤ p.len :=\n  assemblyIndex_le_of_hasLen (S := S) hC z ⟨p, rfl⟩\n\nlemma assemblyIndex_eq_zero_iff (hC : Closed S) (z : S.Ω) :\n    assemblyIndex (S := S) hC z = 0 ↔ z ∈ S.U := by", "pos": {"x": 0.13786274194717407, "y": 0.35194700956344604}, "pos3": {"x": 0.24008223414421082, "y": 0.7230281829833984, "z": 0.8085853457450867}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_eq_zero_iff", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_eq_zero_iff", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 42, "family": "Index", "snippet": "lemma assemblyIndex_eq_zero_iff (hC : Closed S) (z : S.Ω) :\n    assemblyIndex (S := S) hC z = 0 ↔ z ∈ S.U := by\n  constructor\n  · intro hz\n    rcases assemblyIndex_spec (S := S) hC z with ⟨p, hp⟩\n    have hlen0 : p.len = 0 := by simpa [assemblyIndex] using hp.trans hz", "pos": {"x": 0.29735052585601807, "y": 0.5312758088111877}, "pos3": {"x": 0.4231649935245514, "y": 0.5617414712905884, "z": 0.6607811450958252}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 82, "family": "Index", "snippet": "def space : Paper.AssemblySpace where\n  Ω := Obj Atom\n  U := {o | ∃ a, o = Obj.base a}\n  J := fun x y z => z = Obj.join x y\n\nnamespace space", "pos": {"x": 0.9601843953132629, "y": 0.9612379670143127}, "pos3": {"x": 0.9639965891838074, "y": 0.33240506052970886, "z": 0.04134972393512726}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.primitive", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.primitive", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 89, "family": "Index", "snippet": "def primitive (a : Atom) : (space (Atom := Atom)).Ω := Obj.base a\n\n@[simp] lemma mem_U_primitive (a : Atom) : primitive (Atom := Atom) a ∈ (space (Atom := Atom)).U :=\n  ⟨a, rfl⟩\n\n  open Paper.AssemblySpace", "pos": {"x": 0.7198003530502319, "y": 0.8312092423439026}, "pos3": {"x": 0.8258985877037048, "y": 0.132572203874588, "z": 0.38664278388023376}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.mem_U_primitive", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.mem_U_primitive", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 91, "family": "Index", "snippet": "@[simp] lemma mem_U_primitive (a : Atom) : primitive (Atom := Atom) a ∈ (space (Atom := Atom)).U :=\n  ⟨a, rfl⟩\n\n  open Paper.AssemblySpace\n\n  private def canonicalSteps : Obj Atom → List (Step (space (Atom := Atom)))", "pos": {"x": 0.6462987661361694, "y": 0.8041529059410095}, "pos3": {"x": 0.7591145038604736, "y": 0.08872770518064499, "z": 0.48053544759750366}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.canonicalSteps", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.canonicalSteps", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 96, "family": "Index", "snippet": "  private def canonicalSteps : Obj Atom → List (Step (space (Atom := Atom)))\n  | Obj.base _ => []\n  | Obj.join l r =>\n      canonicalSteps l ++ canonicalSteps r ++\n        [{ x := l, y := r, z := Obj.join l r, ok := rfl }]", "pos": {"x": 0.63067227602005, "y": 0.7426528930664062}, "pos3": {"x": 0.7279217839241028, "y": 0.19019265472888947, "z": 0.5050166845321655}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.canonicalPath", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.canonicalPath", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 102, "family": "Index", "snippet": "private def canonicalPath : ∀ o : Obj Atom, AssemblyPath (S := space (Atom := Atom)) o\n  | Obj.base a =>\n      AssemblyPath.primitive (S := space (Atom := Atom)) (z := Obj.base a) (mem_U_primitive (Atom := Atom) a)\n  | Obj.join l r => by\n      classical\n      let pL := canonicalPath l", "pos": {"x": 0.2412211149930954, "y": 0.35622096061706543}, "pos3": {"x": 0.323622465133667, "y": 0.6859921813011169, "z": 0.883466362953186}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 168, "family": "Index", "snippet": "  private noncomputable def reuseAwareSteps (A : Set (Obj Atom)) :\n      Obj Atom → List (Step (space (Atom := Atom)))\n    | Obj.base _ => []\n    | Obj.join l r => by\n        classical\n        by_cases h : Obj.join l r ∈ A", "pos": {"x": 0.5924409031867981, "y": 0.7511017322540283}, "pos3": {"x": 0.7168265581130981, "y": 0.1839100569486618, "z": 0.540904700756073}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.mem_availableAfter_of_mem_steps", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.mem_availableAfter_of_mem_steps", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 182, "family": "Index", "snippet": "  private lemma mem_availableAfter_of_mem_steps (A : Set (Obj Atom)) :\n      ∀ {steps : List (Step (space (Atom := Atom)))} {s : Step (space (Atom := Atom))},\n        s ∈ steps → s.z ∈ availableAfter (S := space (Atom := Atom)) A steps := by\n    intro steps\n    induction steps generalizing A with\n    | nil =>", "pos": {"x": 0.09409645944833755, "y": 0.3037928640842438}, "pos3": {"x": 0.20270442962646484, "y": 0.7137467861175537, "z": 0.8516073822975159}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_z_not_mem", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_z_not_mem", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 203, "family": "Index", "snippet": "  private lemma reuseAwareSteps_z_not_mem (A : Set (Obj Atom)) :\n      ∀ {o : Obj Atom} {s : Step (space (Atom := Atom))},\n        s ∈ reuseAwareSteps (Atom := Atom) A o → s.z ∉ A := by\n    intro o\n    induction o generalizing A with\n    | base a =>", "pos": {"x": 0.38612207770347595, "y": 0.5675464868545532}, "pos3": {"x": 0.4912189245223999, "y": 0.47834619879722595, "z": 0.6407821178436279}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_wf", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_wf", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 240, "family": "Index", "snippet": "  private lemma reuseAwareSteps_wf (A : Set (Obj Atom))\n      (hU : (space (Atom := Atom)).U ⊆ A) :\n      ∀ o : Obj Atom,\n        WellFormedFrom (S := space (Atom := Atom)) A (reuseAwareSteps (Atom := Atom) A o) := by\n    -- First show that the construction always makes its target available.\n    have makes_available :", "pos": {"x": 0.05329682677984238, "y": 0.2220432311296463}, "pos3": {"x": 0.15710732340812683, "y": 0.8038573265075684, "z": 0.905689001083374}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwarePath", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwarePath", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 327, "family": "Index", "snippet": "  private noncomputable def reuseAwarePath : ∀ o : Obj Atom,\n      AssemblyPath (S := space (Atom := Atom)) o\n    | Obj.base a =>\n        AssemblyPath.primitive (S := space (Atom := Atom)) (z := Obj.base a) (mem_U_primitive (Atom := Atom) a)\n    | Obj.join l r => by\n        classical", "pos": {"x": 0.23860183358192444, "y": 0.3532577157020569}, "pos3": {"x": 0.327482134103775, "y": 0.6594229936599731, "z": 0.8896937370300293}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.joinCount_le_of_mem_subobjects", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.joinCount_le_of_mem_subobjects", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 349, "family": "Index", "snippet": "  private lemma joinCount_le_of_mem_subobjects [DecidableEq Atom] :\n      ∀ {o t : Obj Atom}, t ∈ Obj.subobjects o → Obj.joinCount t ≤ Obj.joinCount o := by\n    intro o\n    induction o with\n    | base a =>\n        intro t ht", "pos": {"x": 0.5771971344947815, "y": 0.7822825908660889}, "pos3": {"x": 0.7273510098457336, "y": 0.062129415571689606, "z": 0.49802514910697937}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_not_mem_subobjects_left", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_not_mem_subobjects_left", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 382, "family": "Index", "snippet": "  private lemma join_not_mem_subobjects_left [DecidableEq Atom] (l r : Obj Atom) :\n      Obj.join l r ∉ Obj.subobjects l := by\n    intro hmem\n    have hle : Obj.joinCount (Obj.join l r) ≤ Obj.joinCount l :=\n      joinCount_le_of_mem_subobjects (Atom := Atom) (o := l) (t := Obj.join l r) hmem\n    have hgt : Obj.joinCount (Obj.join l r) > Obj.joinCount l := by", "pos": {"x": 0.018377048894762993, "y": 0.009064270183444023}, "pos3": {"x": 0.02262958139181137, "y": 0.9976169466972351, "z": 0.9268428683280945}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_not_mem_subobjects_right", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_not_mem_subobjects_right", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 391, "family": "Index", "snippet": "  private lemma join_not_mem_subobjects_right [DecidableEq Atom] (l r : Obj Atom) :\n      Obj.join l r ∉ Obj.subobjects r := by\n    intro hmem\n    have hle : Obj.joinCount (Obj.join l r) ≤ Obj.joinCount r :=\n      joinCount_le_of_mem_subobjects (Atom := Atom) (o := r) (t := Obj.join l r) hmem\n    have hgt : Obj.joinCount (Obj.join l r) > Obj.joinCount r := by", "pos": {"x": 0.02976124733686447, "y": 0.014582289382815361}, "pos3": {"x": 0.027772411704063416, "y": 0.9799990653991699, "z": 0.9766016602516174}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_z_mem_subobjects", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_z_mem_subobjects", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 404, "family": "Index", "snippet": "  private lemma reuseAwareSteps_z_mem_subobjects [DecidableEq Atom] (A : Set (Obj Atom)) :\n      ∀ {o : Obj Atom} {s : Step (space (Atom := Atom))},\n        s ∈ reuseAwareSteps (Atom := Atom) A o → s.z ∈ Obj.subobjects o := by\n    intro o\n    induction o generalizing A with\n    | base a =>", "pos": {"x": 0.18228180706501007, "y": 0.3930738866329193}, "pos3": {"x": 0.2821024954319, "y": 0.6847773194313049, "z": 0.8127754330635071}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_z_isJoin", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_z_isJoin", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 446, "family": "Index", "snippet": "  private lemma reuseAwareSteps_z_isJoin (A : Set (Obj Atom)) :\n      ∀ {o : Obj Atom} {s : Step (space (Atom := Atom))},\n        s ∈ reuseAwareSteps (Atom := Atom) A o → Obj.isJoin s.z = true := by\n    intro o\n    induction o generalizing A with\n    | base a =>", "pos": {"x": 0.3267625868320465, "y": 0.5265581607818604}, "pos3": {"x": 0.43965229392051697, "y": 0.5813279151916504, "z": 0.6919084191322327}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_nodup_z", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_nodup_z", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 482, "family": "Index", "snippet": "  private lemma reuseAwareSteps_nodup_z [DecidableEq Atom] (A : Set (Obj Atom)) :\n      ∀ o : Obj Atom, (reuseAwareSteps (Atom := Atom) A o |>.map (fun s => s.z)).Nodup := by\n    intro o\n    induction o generalizing A with\n    | base a => simp [reuseAwareSteps]\n    | join l r ihL ihR =>", "pos": {"x": 0.2061155140399933, "y": 0.391365647315979}, "pos3": {"x": 0.30907824635505676, "y": 0.6884474754333496, "z": 0.7999053597450256}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_len_le_dagJoinCount", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.reuseAwareSteps_len_le_dagJoinCount", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 556, "family": "Index", "snippet": "  private lemma reuseAwareSteps_len_le_dagJoinCount [DecidableEq Atom] (o : Obj Atom) :\n      (reuseAwareSteps (Atom := Atom) (space (Atom := Atom)).U o).length ≤ Obj.dagJoinCount o := by\n    classical\n    let steps := reuseAwareSteps (Atom := Atom) (space (Atom := Atom)).U o\n    let outs := steps.map (fun s => s.z)\n    have hNodup : outs.Nodup := by", "pos": {"x": 0.015008877962827682, "y": 0.04918699339032173}, "pos3": {"x": 0.015080716460943222, "y": 0.9569686055183411, "z": 0.8924672603607178}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.closed", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.closed", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 589, "family": "Index", "snippet": "  lemma closed : Closed (space (Atom := Atom)) := by\n    refine ⟨fun z => ?_⟩\n    exact ⟨canonicalPath (Atom := Atom) z⟩\n\n  lemma assemblyIndex_le_joinCount (o : Obj Atom) :\n      AssemblyIndex.assemblyIndex (S := space (Atom := Atom)) (hC := closed (Atom := Atom)) o ≤ Obj.joinCount o := by", "pos": {"x": 0.24672015011310577, "y": 0.2996571958065033}, "pos3": {"x": 0.3221646845340729, "y": 0.6570505499839783, "z": 0.9768736958503723}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.assemblyIndex_le_joinCount", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.assemblyIndex_le_joinCount", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 593, "family": "Index", "snippet": "  lemma assemblyIndex_le_joinCount (o : Obj Atom) :\n      AssemblyIndex.assemblyIndex (S := space (Atom := Atom)) (hC := closed (Atom := Atom)) o ≤ Obj.joinCount o := by\n  have hlen : (canonicalPath (Atom := Atom) o).len = Obj.joinCount o := by\n    induction o with\n    | base _ => simp [canonicalPath, Obj.joinCount]\n    | join l r ihL ihR =>", "pos": {"x": 0.03814678639173508, "y": 0.04874759167432785}, "pos3": {"x": 0.041891325265169144, "y": 0.9537568092346191, "z": 0.9477344751358032}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.assemblyIndex_le_dagJoinCount", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.assemblyIndex_le_dagJoinCount", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 609, "family": "Index", "snippet": "  lemma assemblyIndex_le_dagJoinCount [DecidableEq Atom] (o : Obj Atom) :\n      AssemblyIndex.assemblyIndex (S := space (Atom := Atom)) (hC := closed (Atom := Atom)) o ≤\n        Obj.dagJoinCount o := by\n    classical\n    -- Use the explicit reuse-aware witness path.\n    let p := reuseAwarePath (Atom := Atom) o", "pos": {"x": 0.08098220080137253, "y": 0.27178677916526794}, "pos3": {"x": 0.17209692299365997, "y": 0.784773051738739, "z": 0.8686032295227051}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_not_mem_U", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_not_mem_U", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 641, "family": "Index", "snippet": "  private lemma join_not_mem_U (t : Obj Atom) (htJoin : Obj.isJoin t = true) :\n      t ∉ (space (Atom := Atom)).U := by\n    cases t with\n    | base a =>\n        simp [Obj.isJoin] at htJoin\n    | join l r =>", "pos": {"x": 0.7034432291984558, "y": 0.8397981524467468}, "pos3": {"x": 0.813571035861969, "y": 0.08447621762752533, "z": 0.4267098307609558}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.exists_step_of_mem_availableAfter", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.exists_step_of_mem_availableAfter", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 651, "family": "Index", "snippet": "  private lemma exists_step_of_mem_availableAfter {A : Set (Obj Atom)} :\n      ∀ {steps : List (Step (space (Atom := Atom)))} {u : Obj Atom},\n        u ∈ availableAfter (S := space (Atom := Atom)) A steps →\n        u ∉ A →\n        ∃ s ∈ steps, s.z = u := by\n    intro steps", "pos": {"x": 0.2559767961502075, "y": 0.48324963450431824}, "pos3": {"x": 0.37108850479125977, "y": 0.6061394214630127, "z": 0.7320456504821777}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.step_inputs_mem_availableAfter", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.step_inputs_mem_availableAfter", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 677, "family": "Index", "snippet": "  private lemma step_inputs_mem_availableAfter {A : Set (Obj Atom)}\n      {steps : List (Step (space (Atom := Atom)))}\n      (wf : WellFormedFrom (S := space (Atom := Atom)) A steps) :\n      ∀ {s : Step (space (Atom := Atom))}, s ∈ steps →\n        s.x ∈ availableAfter (S := space (Atom := Atom)) A steps ∧\n        s.y ∈ availableAfter (S := space (Atom := Atom)) A steps := by", "pos": {"x": 0.030821332708001137, "y": 0.0015360771212726831}, "pos3": {"x": 0.025172371417284012, "y": 0.9475123882293701, "z": 0.9370823502540588}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_components_mem_availableAfter", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_components_mem_availableAfter", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 700, "family": "Index", "snippet": "  private lemma join_components_mem_availableAfter\n      [DecidableEq Atom]\n      {steps : List (Step (space (Atom := Atom)))}\n      (wf : WellFormedFrom (S := space (Atom := Atom)) (space (Atom := Atom)).U steps)\n      (l r : Obj Atom)\n      (hjr : Obj.join l r ∈ availableAfter (S := space (Atom := Atom)) (space (Atom := Atom)).U steps) :", "pos": {"x": 0.043455515056848526, "y": 0.0785018801689148}, "pos3": {"x": 0.0498516671359539, "y": 0.918937087059021, "z": 0.8916246891021729}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.subobjects_mem_availableAfter_of_mem", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.subobjects_mem_availableAfter_of_mem", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 730, "family": "Index", "snippet": "  private lemma subobjects_mem_availableAfter_of_mem\n      [DecidableEq Atom]\n      {steps : List (Step (space (Atom := Atom)))}\n      (wf : WellFormedFrom (S := space (Atom := Atom)) (space (Atom := Atom)).U steps) :\n      ∀ {u : Obj Atom}, u ∈ availableAfter (S := space (Atom := Atom)) (space (Atom := Atom)).U steps →\n        ∀ {t : Obj Atom}, t ∈ Obj.subobjects u →", "pos": {"x": 0.010701427236199379, "y": 0.029336001724004745}, "pos3": {"x": 0.017327096313238144, "y": 0.8942391276359558, "z": 0.9436004161834717}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_subobj_mem_step_outputs", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.join_subobj_mem_step_outputs", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 759, "family": "Index", "snippet": "  private lemma join_subobj_mem_step_outputs\n      [DecidableEq Atom]\n      {o : Obj Atom}\n      (p : AssemblyPath (S := space (Atom := Atom)) o)\n      (t : Obj Atom)\n      (ht : t ∈ Obj.subobjects o)", "pos": {"x": 0.6879602670669556, "y": 0.8292175531387329}, "pos3": {"x": 0.8010210990905762, "y": 0.023509712889790535, "z": 0.41317713260650635}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.dagJoinCount_le_path_len", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.dagJoinCount_le_path_len", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 776, "family": "Index", "snippet": "  private lemma dagJoinCount_le_path_len\n      [DecidableEq Atom]\n      {o : Obj Atom}\n      (p : AssemblyPath (S := space (Atom := Atom)) o) :\n      Obj.dagJoinCount o ≤ p.len := by\n    classical", "pos": {"x": 0.7035486102104187, "y": 0.84173184633255}, "pos3": {"x": 0.8238033056259155, "y": 0.0061249020509421825, "z": 0.40258869528770447}}, {"id": "HeytingLean.ATheory.Paper.ObjSyntax.space.assemblyIndex_eq_dagJoinCount", "name": "HeytingLean.ATheory.Paper.ObjSyntax.space.assemblyIndex_eq_dagJoinCount", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyIndex.lean", "line": 803, "family": "Index", "snippet": "  lemma assemblyIndex_eq_dagJoinCount [DecidableEq Atom] (o : Obj Atom) :\n      AssemblyIndex.assemblyIndex (S := space (Atom := Atom)) (hC := closed (Atom := Atom)) o =\n        Obj.dagJoinCount o := by\n    classical\n    apply Nat.le_antisymm\n    · exact assemblyIndex_le_dagJoinCount (Atom := Atom) (o := o)", "pos": {"x": 0.08746498078107834, "y": 0.309842586517334}, "pos3": {"x": 0.2086448073387146, "y": 0.7073121666908264, "z": 0.856266975402832}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Step", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Step", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 15, "family": "Path", "snippet": "structure Step where\n  x : S.Ω\n  y : S.Ω\n  z : S.Ω\n  ok : S.J x y z", "pos": {"x": 0.9915453195571899, "y": 0.9632158875465393}, "pos3": {"x": 0.9951352477073669, "y": 0.2305227667093277, "z": 0.02777029387652874}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Step", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Step", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 22, "family": "Path", "snippet": "def Step.usable (A : Set S.Ω) (s : Step S) : Prop := s.x ∈ A ∧ s.y ∈ A\n\n/-- Well-formedness of a sequence of join steps, starting from primitives `U`.\n\nAt each step, you may use any previously available object (initially `U`), and the\noutput is added to the available set. This matches the paper’s sequential formulation", "pos": {"x": 0.06324172765016556, "y": 0.20197872817516327}, "pos3": {"x": 0.1440114974975586, "y": 0.8282014727592468, "z": 0.9337266683578491}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.WellFormedFrom", "name": "HeytingLean.ATheory.Paper.AssemblySpace.WellFormedFrom", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 31, "family": "Path", "snippet": "def WellFormedFrom : Set S.Ω → List (Step S) → Prop\n  | _, [] => True\n  | A, s :: ss => s.usable (S := S) A ∧ WellFormedFrom (Set.insert s.z A) ss\n\n@[simp] lemma wellFormedFrom_nil (A : Set S.Ω) : WellFormedFrom (S := S) A [] := True.intro", "pos": {"x": 0.4903842806816101, "y": 0.6580144166946411}, "pos3": {"x": 0.6065029501914978, "y": 0.3389025926589966, "z": 0.5806012153625488}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.wellFormedFrom_nil", "name": "HeytingLean.ATheory.Paper.AssemblySpace.wellFormedFrom_nil", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 35, "family": "Path", "snippet": "@[simp] lemma wellFormedFrom_nil (A : Set S.Ω) : WellFormedFrom (S := S) A [] := True.intro\n\n/-- Compute the set of available objects after executing a step sequence starting from `A`. -/\ndef availableAfter : Set S.Ω → List (Step S) → Set S.Ω\n  | A, [] => A\n  | A, s :: ss => availableAfter (Set.insert s.z A) ss", "pos": {"x": 0.08935211598873138, "y": 0.21488861739635468}, "pos3": {"x": 0.15486732125282288, "y": 0.7313646674156189, "z": 0.9230556488037109}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter", "name": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 38, "family": "Path", "snippet": "def availableAfter : Set S.Ω → List (Step S) → Set S.Ω\n  | A, [] => A\n  | A, s :: ss => availableAfter (Set.insert s.z A) ss\n\n@[simp] lemma availableAfter_nil (A : Set S.Ω) : availableAfter (S := S) A [] = A := rfl", "pos": {"x": 0.6772100329399109, "y": 0.7917325496673584}, "pos3": {"x": 0.7854381799697876, "y": 0.134440615773201, "z": 0.4584959149360657}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter_nil", "name": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter_nil", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 42, "family": "Path", "snippet": "@[simp] lemma availableAfter_nil (A : Set S.Ω) : availableAfter (S := S) A [] = A := rfl\n\nlemma availableAfter_cons (A : Set S.Ω) (s : Step S) (ss : List (Step S)) :\n    availableAfter (S := S) A (s :: ss) = availableAfter (S := S) (Set.insert s.z A) ss := rfl\n\nlemma wellFormedFrom_append {A : Set S.Ω} {xs ys : List (Step S)}", "pos": {"x": 0.04334248974919319, "y": 0.15499702095985413}, "pos3": {"x": 0.10323219001293182, "y": 0.8537391424179077, "z": 0.907008945941925}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter_cons", "name": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter_cons", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 44, "family": "Path", "snippet": "lemma availableAfter_cons (A : Set S.Ω) (s : Step S) (ss : List (Step S)) :\n    availableAfter (S := S) A (s :: ss) = availableAfter (S := S) (Set.insert s.z A) ss := rfl\n\nlemma wellFormedFrom_append {A : Set S.Ω} {xs ys : List (Step S)}\n    (hxs : WellFormedFrom (S := S) A xs)\n    (hys : WellFormedFrom (S := S) (availableAfter (S := S) A xs) ys) :", "pos": {"x": 0.023276150226593018, "y": 0.07280844449996948}, "pos3": {"x": 0.04209202527999878, "y": 0.8232867121696472, "z": 0.9476409554481506}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.wellFormedFrom_append", "name": "HeytingLean.ATheory.Paper.AssemblySpace.wellFormedFrom_append", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 47, "family": "Path", "snippet": "lemma wellFormedFrom_append {A : Set S.Ω} {xs ys : List (Step S)}\n    (hxs : WellFormedFrom (S := S) A xs)\n    (hys : WellFormedFrom (S := S) (availableAfter (S := S) A xs) ys) :\n    WellFormedFrom (S := S) A (xs ++ ys) := by\n  induction xs generalizing A with\n  | nil =>", "pos": {"x": 0.287776917219162, "y": 0.47301656007766724}, "pos3": {"x": 0.40124741196632385, "y": 0.5889310836791992, "z": 0.7663983106613159}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.wellFormedFrom_mono", "name": "HeytingLean.ATheory.Paper.AssemblySpace.wellFormedFrom_mono", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 60, "family": "Path", "snippet": "lemma wellFormedFrom_mono {A B : Set S.Ω} {xs : List (Step S)}\n    (hAB : A ⊆ B) (hxs : WellFormedFrom (S := S) A xs) :\n    WellFormedFrom (S := S) B xs := by\n  induction xs generalizing A B with\n  | nil => simp [WellFormedFrom]\n  | cons s ss ih =>", "pos": {"x": 0.44152164459228516, "y": 0.6156617403030396}, "pos3": {"x": 0.5475542545318604, "y": 0.43044355511665344, "z": 0.6214771270751953}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter_append", "name": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter_append", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 75, "family": "Path", "snippet": "lemma availableAfter_append (A : Set S.Ω) (xs ys : List (Step S)) :\n    availableAfter (S := S) A (xs ++ ys) =\n      availableAfter (S := S) (availableAfter (S := S) A xs) ys := by\n  induction xs generalizing A with\n  | nil => simp [availableAfter]\n  | cons s ss ih =>", "pos": {"x": 0.2983911335468292, "y": 0.5032244324684143}, "pos3": {"x": 0.4194561839103699, "y": 0.6291031837463379, "z": 0.7199718356132507}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.subset_availableAfter", "name": "HeytingLean.ATheory.Paper.AssemblySpace.subset_availableAfter", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 83, "family": "Path", "snippet": "lemma subset_availableAfter (A : Set S.Ω) (xs : List (Step S)) :\n    A ⊆ availableAfter (S := S) A xs := by\n  induction xs generalizing A with\n  | nil => simp [availableAfter]\n  | cons s ss ih =>\n      intro t ht", "pos": {"x": 0.6416947841644287, "y": 0.8218559622764587}, "pos3": {"x": 0.7610905766487122, "y": 0.0, "z": 0.45205169916152954}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter_mono", "name": "HeytingLean.ATheory.Paper.AssemblySpace.availableAfter_mono", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 92, "family": "Path", "snippet": "lemma availableAfter_mono {A B : Set S.Ω} {xs : List (Step S)} (hAB : A ⊆ B) :\n    availableAfter (S := S) A xs ⊆ availableAfter (S := S) B xs := by\n  induction xs generalizing A B with\n  | nil => simpa [availableAfter] using hAB\n  | cons s ss ih =>\n      have hAB' : Set.insert s.z A ⊆ Set.insert s.z B := by", "pos": {"x": 0.07247583568096161, "y": 0.24817034602165222}, "pos3": {"x": 0.17085492610931396, "y": 0.7242183089256287, "z": 0.9215571880340576}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.mem_availableAfter_of_getLast", "name": "HeytingLean.ATheory.Paper.AssemblySpace.mem_availableAfter_of_getLast", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 104, "family": "Path", "snippet": "lemma mem_availableAfter_of_getLast? {A : Set S.Ω} {steps : List (Step S)} {s : Step S}\n    (hs : steps.getLast? = some s) : s.z ∈ availableAfter (S := S) A steps := by\n  induction steps generalizing A with\n  | nil =>\n      simp at hs\n  | cons t ts ih =>", "pos": {"x": 0.3406277000904083, "y": 0.570071816444397}, "pos3": {"x": 0.4541325867176056, "y": 0.4882022738456726, "z": 0.6859081387519836}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 125, "family": "Path", "snippet": "structure AssemblyPath (z : S.Ω) where\n  steps : List (Step S)\n  wf : WellFormedFrom (S := S) S.U steps\n  ok_out :\n    (steps = [] ∧ z ∈ S.U) ∨ (∃ s, steps.getLast? = some s ∧ s.z = z)", "pos": {"x": 0.7837471961975098, "y": 0.90306156873703}, "pos3": {"x": 0.8942474126815796, "y": 0.18071042001247406, "z": 0.3305032253265381}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.len", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.len", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 135, "family": "Path", "snippet": "def len {z : S.Ω} (p : AssemblyPath (S := S) z) : Nat := p.steps.length\n\n@[simp] lemma len_mk {z : S.Ω} (steps) (wf) (ok_out) :\n    len (p := (AssemblyPath.mk (S := S) (z := z) steps wf ok_out)) = steps.length := rfl\n\n/-- The trivial path for a primitive object. -/", "pos": {"x": 0.3313036859035492, "y": 0.4693591296672821}, "pos3": {"x": 0.4352666735649109, "y": 0.5865160822868347, "z": 0.8011446595191956}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.len_mk", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.len_mk", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 137, "family": "Path", "snippet": "@[simp] lemma len_mk {z : S.Ω} (steps) (wf) (ok_out) :\n    len (p := (AssemblyPath.mk (S := S) (z := z) steps wf ok_out)) = steps.length := rfl\n\n/-- The trivial path for a primitive object. -/\ndef primitive {z : S.Ω} (hz : z ∈ S.U) : AssemblyPath (S := S) z :=\n  { steps := []", "pos": {"x": 0.2645558714866638, "y": 0.4202529489994049}, "pos3": {"x": 0.3699018955230713, "y": 0.6701234579086304, "z": 0.8131725192070007}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.primitive", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.primitive", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 141, "family": "Path", "snippet": "def primitive {z : S.Ω} (hz : z ∈ S.U) : AssemblyPath (S := S) z :=\n  { steps := []\n    wf := by simp [WellFormedFrom]\n    ok_out := Or.inl ⟨rfl, hz⟩ }\n\n@[simp] lemma primitive_len {z : S.Ω} (hz : z ∈ S.U) :", "pos": {"x": 0.6507506966590881, "y": 0.8454229831695557}, "pos3": {"x": 0.7849485874176025, "y": 0.022866155952215195, "z": 0.45962363481521606}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.primitive_len", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.primitive_len", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 146, "family": "Path", "snippet": "@[simp] lemma primitive_len {z : S.Ω} (hz : z ∈ S.U) :\n    (primitive (S := S) hz).len = 0 := rfl\n\nlemma mem_availableAfter {z : S.Ω} (p : AssemblyPath (S := S) z) :\n    z ∈ availableAfter (S := S) S.U p.steps := by\n  rcases p.ok_out with ⟨hsteps, hz⟩ | hout", "pos": {"x": 0.3415229916572571, "y": 0.5351027250289917}, "pos3": {"x": 0.4566405415534973, "y": 0.586919367313385, "z": 0.6863813996315002}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.mem_availableAfter", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyPath.mem_availableAfter", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 149, "family": "Path", "snippet": "lemma mem_availableAfter {z : S.Ω} (p : AssemblyPath (S := S) z) :\n    z ∈ availableAfter (S := S) S.U p.steps := by\n  rcases p.ok_out with ⟨hsteps, hz⟩ | hout\n  · simpa [hsteps, availableAfter] using hz\n  · rcases hout with ⟨s, hsLast, hsZ⟩\n    subst hsZ", "pos": {"x": 0.35056814551353455, "y": 0.5560749173164368}, "pos3": {"x": 0.4667331874370575, "y": 0.5032481551170349, "z": 0.6417926549911499}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Closed", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Closed", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyPath.lean", "line": 165, "family": "Path", "snippet": "structure Closed (S : AssemblySpace) : Prop where\n  exists_path : ∀ z : S.Ω, Nonempty (AssemblyPath (S := S) z)\n\nend AssemblySpace\n\nend Paper", "pos": {"x": 0.9680486917495728, "y": 1.0}, "pos3": {"x": 0.9674824476242065, "y": 0.35072222352027893, "z": 0.01958654448390007}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.quotient", "name": "HeytingLean.ATheory.Paper.AssemblySpace.quotient", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 17, "family": "Quotient", "snippet": "def quotient (r : Setoid S.Ω) : AssemblySpace where\n  Ω := Quotient r\n  U := {q | ∃ x ∈ S.U, Quotient.mk r x = q}\n  J := fun qx qy qz =>\n    ∃ x y z,\n      Quotient.mk r x = qx ∧", "pos": {"x": 0.8741090893745422, "y": 0.9180837273597717}, "pos3": {"x": 0.9277867674827576, "y": 0.2432330995798111, "z": 0.19605790078639984}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.mk_mem_U", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.mk_mem_U", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 31, "family": "Quotient", "snippet": "@[simp] lemma mk_mem_U {x : S.Ω} (hx : x ∈ S.U) :\n    Quotient.mk r x ∈ (AssemblySpace.quotient (S := S) r).U :=\n  ⟨x, hx, rfl⟩\n\nprivate def liftSet (A : Set S.Ω) : Set (Quotient r) :=\n  {q | ∃ x ∈ A, Quotient.mk r x = q}", "pos": {"x": 0.6172856688499451, "y": 0.7757939100265503}, "pos3": {"x": 0.7332422733306885, "y": 0.07894732058048248, "z": 0.4571384787559509}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.liftSet", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.liftSet", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 35, "family": "Quotient", "snippet": "private def liftSet (A : Set S.Ω) : Set (Quotient r) :=\n  {q | ∃ x ∈ A, Quotient.mk r x = q}\n\nprivate def mapStep (s : Step (S := S)) : Step (S := AssemblySpace.quotient (S := S) r) where\n  x := Quotient.mk r s.x\n  y := Quotient.mk r s.y", "pos": {"x": 0.5118861794471741, "y": 0.6776541471481323}, "pos3": {"x": 0.628302812576294, "y": 0.28389203548431396, "z": 0.5636938810348511}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.mapStep", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.mapStep", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 38, "family": "Quotient", "snippet": "private def mapStep (s : Step (S := S)) : Step (S := AssemblySpace.quotient (S := S) r) where\n  x := Quotient.mk r s.x\n  y := Quotient.mk r s.y\n  z := Quotient.mk r s.z\n  ok := ⟨s.x, s.y, s.z, rfl, rfl, rfl, s.ok⟩", "pos": {"x": 0.6631713509559631, "y": 0.8148391842842102}, "pos3": {"x": 0.7858371734619141, "y": 0.06925391405820847, "z": 0.47511133551597595}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.map_wf_aux", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.map_wf_aux", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 44, "family": "Quotient", "snippet": "private lemma map_wf_aux (A : Set S.Ω) :\n    ∀ {steps : List (Step (S := S))},\n      WellFormedFrom (S := S) A steps →\n      WellFormedFrom (S := AssemblySpace.quotient (S := S) r) (liftSet (r := r) A)\n        (steps.map (mapStep (S := S) (r := r))) := by\n  intro steps", "pos": {"x": 0.3065902292728424, "y": 0.4590606689453125}, "pos3": {"x": 0.4102576971054077, "y": 0.6095142364501953, "z": 0.790165901184082}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.map_wf", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.map_wf", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 86, "family": "Quotient", "snippet": "private lemma map_wf (p : AssemblyPath (S := S) (z := (z : S.Ω))) :\n    WellFormedFrom (S := AssemblySpace.quotient (S := S) r)\n      (AssemblySpace.quotient (S := S) r).U\n      (p.steps.map (mapStep (S := S) (r := r))) := by\n  have hU : liftSet (r := r) S.U = (AssemblySpace.quotient (S := S) r).U := by\n    ext q", "pos": {"x": 0.07981739938259125, "y": 0.22911319136619568}, "pos3": {"x": 0.16044436395168304, "y": 0.7884204387664795, "z": 0.910339891910553}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.map_ok_out", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.map_ok_out", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 101, "family": "Quotient", "snippet": "private lemma map_ok_out (p : AssemblyPath (S := S) (z := (z : S.Ω))) :\n    ((p.steps.map (mapStep (S := S) (r := r))) = [] ∧\n        Quotient.mk r z ∈ (AssemblySpace.quotient (S := S) r).U) ∨\n      (∃ s,\n        (p.steps.map (mapStep (S := S) (r := r))).getLast? = some s ∧\n          s.z = Quotient.mk r z) := by", "pos": {"x": 0.05861224606633186, "y": 0.24270862340927124}, "pos3": {"x": 0.17882099747657776, "y": 0.7152732610702515, "z": 0.921789288520813}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.mapPath", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Quotient.mapPath", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 123, "family": "Quotient", "snippet": "noncomputable def mapPath (z : S.Ω) (p : AssemblyPath (S := S) z) :\n    AssemblyPath (S := AssemblySpace.quotient (S := S) r) (Quotient.mk r z) :=\n  { steps := p.steps.map (mapStep (S := S) (r := r))\n    wf := by\n      -- The binder form of `map_wf` avoids rewriting `z` in the binder.\n      simpa using (map_wf (S := S) (r := r) (z := z) p)", "pos": {"x": 0.048028748482465744, "y": 0.0649910494685173}, "pos3": {"x": 0.06559696793556213, "y": 0.9027011394500732, "z": 0.9180652499198914}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.Closed.quotient", "name": "HeytingLean.ATheory.Paper.AssemblySpace.Closed.quotient", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 139, "family": "Quotient", "snippet": "noncomputable def quotient (hC : Closed S) (r : Setoid S.Ω) :\n    Closed (AssemblySpace.quotient (S := S) r) := by\n  classical\n  refine ⟨fun q => ?_⟩\n  refine Quotient.inductionOn q (fun z => ?_) \n  rcases hC.exists_path z with ⟨p⟩", "pos": {"x": 0.561161994934082, "y": 0.7060137987136841}, "pos3": {"x": 0.6711490750312805, "y": 0.20858299732208252, "z": 0.5780898332595825}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_quotient_le", "name": "HeytingLean.ATheory.Paper.AssemblySpace.AssemblyIndex.assemblyIndex_quotient_le", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblyQuotient.lean", "line": 153, "family": "Quotient", "snippet": "lemma assemblyIndex_quotient_le (hC : Closed S) (r : Setoid S.Ω) (z : S.Ω) :\n    AssemblyIndex.assemblyIndex (S := AssemblySpace.quotient (S := S) r)\n        (hC := Closed.quotient (S := S) hC r) (Quotient.mk r z)\n      ≤ AssemblyIndex.assemblyIndex (S := S) (hC := hC) z := by\n  classical\n  rcases assemblyIndex_spec (S := S) (hC := hC) z with ⟨p, hp⟩", "pos": {"x": 0.041109099984169006, "y": 0.013194524683058262}, "pos3": {"x": 0.0005177502753213048, "y": 0.8636496663093567, "z": 0.9179839491844177}}, {"id": "HeytingLean.ATheory.Paper.AssemblySpace", "name": "HeytingLean.ATheory.Paper.AssemblySpace", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/AssemblySpace.lean", "line": 17, "family": "Space", "snippet": "structure AssemblySpace where\n  Ω : Type u\n  U : Set Ω\n  /-- `J x y z` means `x` and `y` can be causally joined to form `z`. -/\n  J : Ω → Ω → Ω → Prop", "pos": {"x": 0.9744870066642761, "y": 0.9344291687011719}, "pos3": {"x": 0.9820476770401001, "y": 0.2284625768661499, "z": 0.07880228757858276}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.Graph", "name": "HeytingLean.ATheory.Paper.BHypergraph.Graph", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 34, "family": "Hypergraph", "snippet": "structure Graph where\n  V : Type u\n  U : Set V\n  E : V → V → V → Prop\n\n/-- View a B-hypergraph as a paper-facing `AssemblySpace`. -/", "pos": {"x": 0.9796390533447266, "y": 0.9539583325386047}, "pos3": {"x": 0.9799391627311707, "y": 0.29902079701423645, "z": 0.008489739149808884}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.toAssemblySpace", "name": "HeytingLean.ATheory.Paper.BHypergraph.toAssemblySpace", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 40, "family": "Hypergraph", "snippet": "def toAssemblySpace (H : Graph) : AssemblySpace where\n  Ω := H.V\n  U := H.U\n  J := H.E\n\n/-- A hyperedge packaged with evidence it is allowed (same data as `AssemblySpace.Step`). -/", "pos": {"x": 0.8152647018432617, "y": 0.9096352458000183}, "pos3": {"x": 0.9094163775444031, "y": 0.19990670680999756, "z": 0.2776613235473633}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.Edge", "name": "HeytingLean.ATheory.Paper.BHypergraph.Edge", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 46, "family": "Hypergraph", "snippet": "abbrev Edge (H : Graph) := AssemblySpace.Step (S := toAssemblySpace H)\n\n/-- A reuse-capable sequential hyperpath for `z` (definitional alias of `AssemblyPath`). -/\nabbrev HyperPath (H : Graph) (z : H.V) :=\n  AssemblySpace.AssemblyPath (S := toAssemblySpace H) z", "pos": {"x": 0.36285170912742615, "y": 0.4350070655345917}, "pos3": {"x": 0.4423495829105377, "y": 0.5988988280296326, "z": 0.8336243033409119}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.HyperPath", "name": "HeytingLean.ATheory.Paper.BHypergraph.HyperPath", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 49, "family": "Hypergraph", "snippet": "abbrev HyperPath (H : Graph) (z : H.V) :=\n  AssemblySpace.AssemblyPath (S := toAssemblySpace H) z\n\nabbrev Closed (H : Graph) : Prop := AssemblySpace.Closed (toAssemblySpace H)\n\nnamespace HyperIndex", "pos": {"x": 0.7624511122703552, "y": 0.8805218935012817}, "pos3": {"x": 0.8754570484161377, "y": 0.10270575433969498, "z": 0.34021803736686707}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.Closed", "name": "HeytingLean.ATheory.Paper.BHypergraph.Closed", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 52, "family": "Hypergraph", "snippet": "abbrev Closed (H : Graph) : Prop := AssemblySpace.Closed (toAssemblySpace H)\n\nnamespace HyperIndex\n\n/-- A vertex `z` has a hyperpath of length `n`. -/\ndef HasHyperPathLen (H : Graph) (z : H.V) (n : Nat) : Prop :=", "pos": {"x": 0.7352441549301147, "y": 0.8025268316268921}, "pos3": {"x": 0.8156410455703735, "y": 0.21876947581768036, "z": 0.3999898433685303}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.HasHyperPathLen", "name": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.HasHyperPathLen", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 57, "family": "Hypergraph", "snippet": "def HasHyperPathLen (H : Graph) (z : H.V) (n : Nat) : Prop :=\n  ∃ p : HyperPath H z, p.len = n\n\n/-- The minimal hyperpath length (hypergraph view of `AssemblyIndex.assemblyIndex`). -/\nnoncomputable def hyperIndex (H : Graph) (hC : Closed H) (z : H.V) : Nat :=\n  AssemblySpace.AssemblyIndex.assemblyIndex (S := toAssemblySpace H) (hC := hC) z", "pos": {"x": 0.060614120215177536, "y": 0.058972738683223724}, "pos3": {"x": 0.038196761161088943, "y": 0.9115263223648071, "z": 1.0}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex", "name": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 61, "family": "Hypergraph", "snippet": "noncomputable def hyperIndex (H : Graph) (hC : Closed H) (z : H.V) : Nat :=\n  AssemblySpace.AssemblyIndex.assemblyIndex (S := toAssemblySpace H) (hC := hC) z\n\nlemma hyperIndex_spec (H : Graph) (hC : Closed H) (z : H.V) :\n    HasHyperPathLen H z (hyperIndex H hC z) := by\n  rcases AssemblySpace.AssemblyIndex.assemblyIndex_spec (S := toAssemblySpace H) hC z with ⟨p, hp⟩", "pos": {"x": 0.025561727583408356, "y": 0.023484380915760994}, "pos3": {"x": 0.018852688372135162, "y": 0.9376059174537659, "z": 0.969876766204834}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex_spec", "name": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex_spec", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 64, "family": "Hypergraph", "snippet": "lemma hyperIndex_spec (H : Graph) (hC : Closed H) (z : H.V) :\n    HasHyperPathLen H z (hyperIndex H hC z) := by\n  rcases AssemblySpace.AssemblyIndex.assemblyIndex_spec (S := toAssemblySpace H) hC z with ⟨p, hp⟩\n  exact ⟨p, hp⟩\n\nlemma hyperIndex_le_of_hasLen (H : Graph) (hC : Closed H) (z : H.V) {n : Nat}", "pos": {"x": 0.11694999039173126, "y": 0.26834163069725037}, "pos3": {"x": 0.19547656178474426, "y": 0.7438094019889832, "z": 0.8788039684295654}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex_le_of_hasLen", "name": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex_le_of_hasLen", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 69, "family": "Hypergraph", "snippet": "lemma hyperIndex_le_of_hasLen (H : Graph) (hC : Closed H) (z : H.V) {n : Nat}\n    (hn : HasHyperPathLen H z n) :\n    hyperIndex H hC z ≤ n := by\n  rcases hn with ⟨p, hp⟩\n  have :\n      AssemblySpace.AssemblyIndex.assemblyIndex (S := toAssemblySpace H) (hC := hC) z ≤ n := by", "pos": {"x": 0.23880316317081451, "y": 0.47540050745010376}, "pos3": {"x": 0.37590479850769043, "y": 0.6392746567726135, "z": 0.7063777446746826}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex_le_of_path", "name": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex_le_of_path", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 78, "family": "Hypergraph", "snippet": "lemma hyperIndex_le_of_path (H : Graph) (hC : Closed H) {z : H.V} (p : HyperPath H z) :\n    hyperIndex H hC z ≤ p.len := by\n  simpa [hyperIndex] using\n    (AssemblySpace.AssemblyIndex.assemblyIndex_le_of_path (S := toAssemblySpace H) hC p)\n\nend HyperIndex", "pos": {"x": 0.3504975140094757, "y": 0.5672431588172913}, "pos3": {"x": 0.47425973415374756, "y": 0.5357294678688049, "z": 0.6610439419746399}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.ofAssemblySpace", "name": "HeytingLean.ATheory.Paper.BHypergraph.ofAssemblySpace", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 88, "family": "Hypergraph", "snippet": "def ofAssemblySpace (S : AssemblySpace) : Graph where\n  V := S.Ω\n  U := S.U\n  E := S.J\n\n@[simp] lemma toAssemblySpace_ofAssemblySpace (S : AssemblySpace) :", "pos": {"x": 0.9618393182754517, "y": 0.9179728627204895}, "pos3": {"x": 0.9775453209877014, "y": 0.2794080972671509, "z": 0.10331059247255325}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.toAssemblySpace_ofAssemblySpace", "name": "HeytingLean.ATheory.Paper.BHypergraph.toAssemblySpace_ofAssemblySpace", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 93, "family": "Hypergraph", "snippet": "@[simp] lemma toAssemblySpace_ofAssemblySpace (S : AssemblySpace) :\n    toAssemblySpace (ofAssemblySpace S) = S := rfl\n\nnamespace HyperIndex\n\n@[simp] lemma hyperIndex_ofAssemblySpace_eq (S : AssemblySpace) (hC : AssemblySpace.Closed S) (z : S.Ω) :", "pos": {"x": 0.4082631766796112, "y": 0.60622239112854}, "pos3": {"x": 0.5249327421188354, "y": 0.4512873589992523, "z": 0.6190729141235352}}, {"id": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex_ofAssemblySpace_eq", "name": "HeytingLean.ATheory.Paper.BHypergraph.HyperIndex.hyperIndex_ofAssemblySpace_eq", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/HypergraphSpace.lean", "line": 98, "family": "Hypergraph", "snippet": "@[simp] lemma hyperIndex_ofAssemblySpace_eq (S : AssemblySpace) (hC : AssemblySpace.Closed S) (z : S.Ω) :\n    hyperIndex (H := ofAssemblySpace S) (hC := by simpa using hC) z =\n      AssemblySpace.AssemblyIndex.assemblyIndex (S := S) (hC := hC) z := rfl\n\nend HyperIndex", "pos": {"x": 0.3215116858482361, "y": 0.5479808449745178}, "pos3": {"x": 0.43165063858032227, "y": 0.5263898968696594, "z": 0.667164146900177}}, {"id": "HeytingLean.ATheory.Paper.Molecular.Bond", "name": "HeytingLean.ATheory.Paper.Molecular.Bond", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 47, "family": "Molecular", "snippet": "structure Bond (Atom : Type u) where\n  id : Nat\n  a : Atom\n  b : Atom\nderiving DecidableEq", "pos": {"x": 1.0, "y": 0.9733399152755737}, "pos3": {"x": 1.0, "y": 0.33573517203330994, "z": 0.03555900231003761}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolLabel", "name": "HeytingLean.ATheory.Paper.Molecular.MolLabel", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 67, "family": "Molecular", "snippet": "abbrev MolLabel (Atom : Type u) := Atom ⊕ Nat\n\n/-- A finite labelled simple graph (hydrogen-suppressed), used as a semantics target.\n\n`V` is an abstract finite vertex type; `label` assigns a label in `Atom ⊕ Nat` to each vertex.\nThe underlying graph is unlabelled.", "pos": {"x": 0.32706397771835327, "y": 0.41872087121009827}, "pos3": {"x": 0.42518046498298645, "y": 0.6234166026115417, "z": 0.8600810766220093}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolGraph", "name": "HeytingLean.ATheory.Paper.Molecular.MolGraph", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 75, "family": "Molecular", "snippet": "structure MolGraph (Atom : Type u) where\n  V : Type\n  [instFintype : Fintype V]\n  [instDecEq : DecidableEq V]\n  label : V → MolLabel Atom\n  graph : SimpleGraph V", "pos": {"x": 0.9402626156806946, "y": 0.9152758717536926}, "pos3": {"x": 0.966263473033905, "y": 0.3048519194126129, "z": 0.12082505971193314}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolIso", "name": "HeytingLean.ATheory.Paper.Molecular.MolIso", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 86, "family": "Molecular", "snippet": "def MolIso (G H : MolGraph Atom) : Prop :=\n  ∃ iso : G.graph ≃g H.graph, ∀ v, H.label (iso v) = G.label v\n\nlemma molIso_refl (G : MolGraph Atom) : MolIso (Atom := Atom) G G := by\n  refine ⟨SimpleGraph.Iso.refl (G := G.graph), ?_⟩\n  intro v", "pos": {"x": 0.5558522939682007, "y": 0.62887042760849}, "pos3": {"x": 0.6421692371368408, "y": 0.3713570237159729, "z": 0.6411684155464172}}, {"id": "HeytingLean.ATheory.Paper.Molecular.molIso_refl", "name": "HeytingLean.ATheory.Paper.Molecular.molIso_refl", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 89, "family": "Molecular", "snippet": "lemma molIso_refl (G : MolGraph Atom) : MolIso (Atom := Atom) G G := by\n  refine ⟨SimpleGraph.Iso.refl (G := G.graph), ?_⟩\n  intro v\n  simp\n\nlemma molIso_symm {G H : MolGraph Atom} :", "pos": {"x": 0.8479377031326294, "y": 0.9019545316696167}, "pos3": {"x": 0.9196836352348328, "y": 0.23516376316547394, "z": 0.24034245312213898}}, {"id": "HeytingLean.ATheory.Paper.Molecular.molIso_symm", "name": "HeytingLean.ATheory.Paper.Molecular.molIso_symm", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 94, "family": "Molecular", "snippet": "lemma molIso_symm {G H : MolGraph Atom} :\n    MolIso (Atom := Atom) G H → MolIso (Atom := Atom) H G := by\n  rintro ⟨iso, hlabel⟩\n  refine ⟨iso.symm, ?_⟩\n  intro v\n  -- apply `hlabel` at `iso.symm v`", "pos": {"x": 0.7757182717323303, "y": 0.8764181137084961}, "pos3": {"x": 0.850808322429657, "y": 0.1286504715681076, "z": 0.2960861623287201}}, {"id": "HeytingLean.ATheory.Paper.Molecular.molIso_trans", "name": "HeytingLean.ATheory.Paper.Molecular.molIso_trans", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 103, "family": "Molecular", "snippet": "lemma molIso_trans {G H K : MolGraph Atom} :\n    MolIso (Atom := Atom) G H → MolIso (Atom := Atom) H K → MolIso (Atom := Atom) G K := by\n  rintro ⟨iso1, h1⟩ ⟨iso2, h2⟩\n  refine ⟨iso1.trans iso2, ?_⟩\n  intro v\n  have h2' := h2 (iso1 v)", "pos": {"x": 0.5446270108222961, "y": 0.6539303064346313}, "pos3": {"x": 0.6464640498161316, "y": 0.3228471279144287, "z": 0.5729572772979736}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolGraph.IsAtomVertex", "name": "HeytingLean.ATheory.Paper.Molecular.MolGraph.IsAtomVertex", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 126, "family": "Molecular", "snippet": "def IsAtomVertex (G : MolGraph Atom) (v : G.V) : Prop :=\n  ∃ a : Atom, G.label v = Sum.inl a\n\n/-- Predicate: a vertex carries a bond-id label. -/\ndef IsBondVertex (G : MolGraph Atom) (v : G.V) : Prop :=\n  ∃ n : Nat, G.label v = Sum.inr n", "pos": {"x": 0.5189490914344788, "y": 0.6883013844490051}, "pos3": {"x": 0.6171485781669617, "y": 0.24873635172843933, "z": 0.5374232530593872}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolGraph.IsBondVertex", "name": "HeytingLean.ATheory.Paper.Molecular.MolGraph.IsBondVertex", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 130, "family": "Molecular", "snippet": "def IsBondVertex (G : MolGraph Atom) (v : G.V) : Prop :=\n  ∃ n : Nat, G.label v = Sum.inr n\n\ndef disjointUnion (G H : MolGraph Atom) : MolGraph Atom where\n  V := G.V ⊕ H.V\n  label := Sum.elim G.label H.label", "pos": {"x": 0.6914207935333252, "y": 0.8550134897232056}, "pos3": {"x": 0.8098217844963074, "y": 0.06871328502893448, "z": 0.35864418745040894}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolGraph.disjointUnion", "name": "HeytingLean.ATheory.Paper.Molecular.MolGraph.disjointUnion", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 133, "family": "Molecular", "snippet": "def disjointUnion (G H : MolGraph Atom) : MolGraph Atom where\n  V := G.V ⊕ H.V\n  label := Sum.elim G.label H.label\n  graph := G.graph ⊕g H.graph\n\nnoncomputable def identify (G H : MolGraph Atom) (v : G.V) (w : H.V) : MolGraph Atom := by", "pos": {"x": 0.5275390148162842, "y": 0.7062410712242126}, "pos3": {"x": 0.6335774064064026, "y": 0.24682100117206573, "z": 0.5429344177246094}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolGraph.identify", "name": "HeytingLean.ATheory.Paper.Molecular.MolGraph.identify", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 138, "family": "Molecular", "snippet": "noncomputable def identify (G H : MolGraph Atom) (v : G.V) (w : H.V) : MolGraph Atom := by\n  classical\n  let U : MolGraph Atom := disjointUnion (Atom := Atom) G H\n  let s : U.V := Sum.inl v\n  let t : U.V := Sum.inr w\n  -- Make `s` inherit all neighbours of `t`, then delete `t`.", "pos": {"x": 0.2761401832103729, "y": 0.3799446225166321}, "pos3": {"x": 0.36285164952278137, "y": 0.6455425024032593, "z": 0.8741772174835205}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolGraph.IsJoinAtom", "name": "HeytingLean.ATheory.Paper.Molecular.MolGraph.IsJoinAtom", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 159, "family": "Molecular", "snippet": "def IsJoinAtom (G H K : MolGraph Atom) : Prop :=\n  ∃ (v : G.V) (w : H.V),\n    IsAtomVertex (Atom := Atom) G v ∧\n    IsAtomVertex (Atom := Atom) H w ∧\n    MolIso (Atom := Atom) K (identify (Atom := Atom) G H v w)", "pos": {"x": 0.6682406067848206, "y": 0.8505110144615173}, "pos3": {"x": 0.7903177738189697, "y": 0.09393873065710068, "z": 0.4193389415740967}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolState", "name": "HeytingLean.ATheory.Paper.Molecular.MolState", "kind": "structure", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 175, "family": "Molecular", "snippet": "structure MolState (Atom : Type u) where\n  core : MolGraph Atom\n  port : core.V\n\nnamespace MolState", "pos": {"x": 0.9772209525108337, "y": 0.9363317489624023}, "pos3": {"x": 0.9848922491073608, "y": 0.32227304577827454, "z": 0.0}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolState.disjointUnion", "name": "HeytingLean.ATheory.Paper.Molecular.MolState.disjointUnion", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 181, "family": "Molecular", "snippet": "def disjointUnion (G H : MolState Atom) : MolState Atom where\n  core := MolGraph.disjointUnion (Atom := Atom) G.core H.core\n  port := Sum.inl G.port\n\nnoncomputable def join (G H : MolState Atom) : MolState Atom := by\n  classical", "pos": {"x": 0.5563961863517761, "y": 0.7351325750350952}, "pos3": {"x": 0.6812772750854492, "y": 0.17121943831443787, "z": 0.5124134421348572}}, {"id": "HeytingLean.ATheory.Paper.Molecular.MolState.join", "name": "HeytingLean.ATheory.Paper.Molecular.MolState.join", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 185, "family": "Molecular", "snippet": "noncomputable def join (G H : MolState Atom) : MolState Atom := by\n  classical\n  -- Identify left port with right port.\n  let core' := MolGraph.identify (Atom := Atom) G.core H.core G.port H.port\n  exact\n    { core := core'", "pos": {"x": 0.6454736590385437, "y": 0.7388083338737488}, "pos3": {"x": 0.7419651746749878, "y": 0.2521512508392334, "z": 0.5047475099563599}}, {"id": "HeytingLean.ATheory.Paper.Molecular.evalBond", "name": "HeytingLean.ATheory.Paper.Molecular.evalBond", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 197, "family": "Molecular", "snippet": "def evalBond (b : Bond Atom) : MolState Atom := by\n  classical\n  -- Encode a *unique bond* inside `SimpleGraph` by introducing an explicit bond-vertex.\n  -- Vertices are labelled by `Atom ⊕ Nat`, where `Sum.inr b.id` tags the bond instance.\n  let Label := Atom ⊕ Nat\n  let V : Type := Fin 3", "pos": {"x": 0.2694089114665985, "y": 0.3144318759441376}, "pos3": {"x": 0.3210909068584442, "y": 0.7808206677436829, "z": 0.9762995839118958}}, {"id": "HeytingLean.ATheory.Paper.Molecular.evalObj", "name": "HeytingLean.ATheory.Paper.Molecular.evalObj", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 217, "family": "Molecular", "snippet": "noncomputable def evalObj : Obj (Bond Atom) → MolState Atom\n  | Obj.base b => evalBond (Atom := Atom) b\n  | Obj.join x y => MolState.join (Atom := Atom) (evalObj x) (evalObj y)\n\nnoncomputable def evalCore (o : Obj (Bond Atom)) : MolGraph Atom :=\n  (evalObj (Atom := Atom) o).core", "pos": {"x": 0.2894324064254761, "y": 0.3358459174633026}, "pos3": {"x": 0.35039252042770386, "y": 0.7282141447067261, "z": 0.9427237510681152}}, {"id": "HeytingLean.ATheory.Paper.Molecular.evalCore", "name": "HeytingLean.ATheory.Paper.Molecular.evalCore", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 221, "family": "Molecular", "snippet": "noncomputable def evalCore (o : Obj (Bond Atom)) : MolGraph Atom :=\n  (evalObj (Atom := Atom) o).core\n\n/-! ## Option B: quotient-by-isomorphism space -/\n\ndef evalIsoRel (x y : Obj (Bond Atom)) : Prop :=", "pos": {"x": 0.7740511298179626, "y": 0.8461472392082214}, "pos3": {"x": 0.8484542369842529, "y": 0.25230172276496887, "z": 0.3663405478000641}}, {"id": "HeytingLean.ATheory.Paper.Molecular.evalIsoRel", "name": "HeytingLean.ATheory.Paper.Molecular.evalIsoRel", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 226, "family": "Molecular", "snippet": "def evalIsoRel (x y : Obj (Bond Atom)) : Prop :=\n  MolIso (Atom := Atom) (evalCore (Atom := Atom) x) (evalCore (Atom := Atom) y)\n\nprivate theorem evalIsoRel_refl (x : Obj (Bond Atom)) : evalIsoRel (Atom := Atom) x x :=\n  molIso_refl (Atom := Atom) (evalCore (Atom := Atom) x)", "pos": {"x": 0.3050782382488251, "y": 0.3640784025192261}, "pos3": {"x": 0.37192049622535706, "y": 0.6713255047798157, "z": 0.9231170415878296}}, {"id": "HeytingLean.ATheory.Paper.Molecular.evalIsoRel_refl", "name": "HeytingLean.ATheory.Paper.Molecular.evalIsoRel_refl", "kind": "theorem", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 229, "family": "Molecular", "snippet": "private theorem evalIsoRel_refl (x : Obj (Bond Atom)) : evalIsoRel (Atom := Atom) x x :=\n  molIso_refl (Atom := Atom) (evalCore (Atom := Atom) x)\n\nprivate theorem evalIsoRel_symm {x y : Obj (Bond Atom)} :\n    evalIsoRel (Atom := Atom) x y → evalIsoRel (Atom := Atom) y x := by\n  exact molIso_symm (Atom := Atom)", "pos": {"x": 0.09827885776758194, "y": 0.20496733486652374}, "pos3": {"x": 0.17596954107284546, "y": 0.8205695152282715, "z": 0.9504654407501221}}, {"id": "HeytingLean.ATheory.Paper.Molecular.evalIsoRel_symm", "name": "HeytingLean.ATheory.Paper.Molecular.evalIsoRel_symm", "kind": "theorem", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 232, "family": "Molecular", "snippet": "private theorem evalIsoRel_symm {x y : Obj (Bond Atom)} :\n    evalIsoRel (Atom := Atom) x y → evalIsoRel (Atom := Atom) y x := by\n  exact molIso_symm (Atom := Atom)\n\nprivate theorem evalIsoRel_trans {x y z : Obj (Bond Atom)} :\n    evalIsoRel (Atom := Atom) x y → evalIsoRel (Atom := Atom) y z → evalIsoRel (Atom := Atom) x z := by", "pos": {"x": 0.05424726754426956, "y": 0.13490749895572662}, "pos3": {"x": 0.09590386599302292, "y": 0.8445450663566589, "z": 0.9598054885864258}}, {"id": "HeytingLean.ATheory.Paper.Molecular.evalIsoRel_trans", "name": "HeytingLean.ATheory.Paper.Molecular.evalIsoRel_trans", "kind": "theorem", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 236, "family": "Molecular", "snippet": "private theorem evalIsoRel_trans {x y z : Obj (Bond Atom)} :\n    evalIsoRel (Atom := Atom) x y → evalIsoRel (Atom := Atom) y z → evalIsoRel (Atom := Atom) x z := by\n  exact molIso_trans (Atom := Atom)\n\ndef evalIsoSetoid : Setoid (Obj (Bond Atom)) :=\n  Setoid.mk (evalIsoRel (Atom := Atom))", "pos": {"x": 0.22880518436431885, "y": 0.3284516930580139}, "pos3": {"x": 0.3161613643169403, "y": 0.7647439241409302, "z": 0.9263630509376526}}, {"id": "HeytingLean.ATheory.Paper.Molecular.evalIsoSetoid", "name": "HeytingLean.ATheory.Paper.Molecular.evalIsoSetoid", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 240, "family": "Molecular", "snippet": "def evalIsoSetoid : Setoid (Obj (Bond Atom)) :=\n  Setoid.mk (evalIsoRel (Atom := Atom))\n    ⟨evalIsoRel_refl (Atom := Atom),\n     by intro x y; exact evalIsoRel_symm (Atom := Atom),\n     by intro x y z; exact evalIsoRel_trans (Atom := Atom)⟩", "pos": {"x": 0.4961857497692108, "y": 0.6386631727218628}, "pos3": {"x": 0.6180533766746521, "y": 0.4075339138507843, "z": 0.6252092719078064}}, {"id": "HeytingLean.ATheory.Paper.Molecular.molSpace", "name": "HeytingLean.ATheory.Paper.Molecular.molSpace", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 250, "family": "Molecular", "snippet": "def molSpace (Atom : Type u) : AssemblySpace :=\n  AssemblySpace.quotient\n    (S := ObjSyntax.space (Atom := Bond Atom))\n    (evalIsoSetoid (Atom := Atom))\n\nnoncomputable def closed (Atom : Type u) : AssemblySpace.Closed (molSpace (Atom := Atom)) := by", "pos": {"x": 0.4894142746925354, "y": 0.596676766872406}, "pos3": {"x": 0.5847687125205994, "y": 0.3968471586704254, "z": 0.6419742703437805}}, {"id": "HeytingLean.ATheory.Paper.Molecular.closed", "name": "HeytingLean.ATheory.Paper.Molecular.closed", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 255, "family": "Molecular", "snippet": "noncomputable def closed (Atom : Type u) : AssemblySpace.Closed (molSpace (Atom := Atom)) := by\n  simpa [molSpace] using\n    (AssemblySpace.Closed.quotient\n      (S := ObjSyntax.space (Atom := Bond Atom))\n      (ObjSyntax.space.closed (Atom := Bond Atom))\n      (evalIsoSetoid (Atom := Atom)))", "pos": {"x": 0.26295995712280273, "y": 0.31943362951278687}, "pos3": {"x": 0.33751845359802246, "y": 0.706153929233551, "z": 0.982764482498169}}, {"id": "HeytingLean.ATheory.Paper.Molecular.assemblyIndex_syntax_eq_dagJoinCount", "name": "HeytingLean.ATheory.Paper.Molecular.assemblyIndex_syntax_eq_dagJoinCount", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 270, "family": "Molecular", "snippet": "lemma assemblyIndex_syntax_eq_dagJoinCount [DecidableEq Atom] (o : Obj (Bond Atom)) :\n    AssemblySpace.AssemblyIndex.assemblyIndex\n        (S := ObjSyntax.space (Atom := Bond Atom))\n        (hC := ObjSyntax.space.closed (Atom := Bond Atom)) o\n      = Obj.dagJoinCount o := by\n  simpa using", "pos": {"x": 0.15739119052886963, "y": 0.36989834904670715}, "pos3": {"x": 0.27465692162513733, "y": 0.6966907978057861, "z": 0.803901195526123}}, {"id": "HeytingLean.ATheory.Paper.Molecular.assemblyIndex_mol_le_dagJoinCount", "name": "HeytingLean.ATheory.Paper.Molecular.assemblyIndex_mol_le_dagJoinCount", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/MolecularSpace.lean", "line": 278, "family": "Molecular", "snippet": "lemma assemblyIndex_mol_le_dagJoinCount [DecidableEq Atom] (o : Obj (Bond Atom)) :\n    AssemblySpace.AssemblyIndex.assemblyIndex\n        (S := molSpace (Atom := Atom))\n        (hC := closed (Atom := Atom))\n        (Quotient.mk (evalIsoSetoid (Atom := Atom)) o)\n      ≤ Obj.dagJoinCount o := by", "pos": {"x": 0.16048775613307953, "y": 0.33449748158454895}, "pos3": {"x": 0.2585664391517639, "y": 0.7037708759307861, "z": 0.8670427203178406}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.spaceRules", "name": "HeytingLean.ATheory.Paper.StringPerm.spaceRules", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 40, "family": "Space", "snippet": "def spaceRules (Allowed : List Atom → List Atom → Prop) : Paper.AssemblySpace where\n  Ω := List Atom\n  U := {xs | xs = [] ∨ ∃ a, xs = [a]}\n  J := fun x y z => Allowed x y ∧ List.Perm (x ++ y) z\n\n/-- Default “total rule” instance: every pair is joinable. -/", "pos": {"x": 0.4661378860473633, "y": 0.5637224316596985}, "pos3": {"x": 0.5672053098678589, "y": 0.47219687700271606, "z": 0.6938462853431702}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.space", "name": "HeytingLean.ATheory.Paper.StringPerm.space", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 46, "family": "Space", "snippet": "def space : Paper.AssemblySpace :=\n  spaceRules (Atom := Atom) (fun _ _ => True)\n\nnamespace spaceRules\n\nvariable {Allowed : List Atom → List Atom → Prop}", "pos": {"x": 0.939005970954895, "y": 0.9485365748405457}, "pos3": {"x": 0.9886143207550049, "y": 0.25179269909858704, "z": 0.07319609820842743}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.spaceRules.mem_U_nil", "name": "HeytingLean.ATheory.Paper.StringPerm.spaceRules.mem_U_nil", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 53, "family": "Space", "snippet": "@[simp] lemma mem_U_nil : ([] : List Atom) ∈ (spaceRules (Atom := Atom) Allowed).U :=\n  Or.inl rfl\n\n@[simp] lemma mem_U_singleton (a : Atom) : ([a] : List Atom) ∈ (spaceRules (Atom := Atom) Allowed).U :=\n  Or.inr ⟨a, rfl⟩", "pos": {"x": 0.6216630339622498, "y": 0.782423198223114}, "pos3": {"x": 0.7420797348022461, "y": 0.10656334459781647, "z": 0.5509145855903625}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.spaceRules.mem_U_singleton", "name": "HeytingLean.ATheory.Paper.StringPerm.spaceRules.mem_U_singleton", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 56, "family": "Space", "snippet": "@[simp] lemma mem_U_singleton (a : Atom) : ([a] : List Atom) ∈ (spaceRules (Atom := Atom) Allowed).U :=\n  Or.inr ⟨a, rfl⟩\n\n/-- Closure holds if the rule predicate is total. -/\nnoncomputable def closed_of_total (hAllowed : ∀ x y, Allowed x y) :\n    Closed (spaceRules (Atom := Atom) Allowed) := by", "pos": {"x": 0.14770925045013428, "y": 0.3076571822166443}, "pos3": {"x": 0.2504451274871826, "y": 0.7179729342460632, "z": 0.8822546005249023}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.spaceRules.closed_of_total", "name": "HeytingLean.ATheory.Paper.StringPerm.spaceRules.closed_of_total", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 60, "family": "Space", "snippet": "noncomputable def closed_of_total (hAllowed : ∀ x y, Allowed x y) :\n    Closed (spaceRules (Atom := Atom) Allowed) := by\n  classical\n  refine ⟨fun z => ?_⟩\n  -- A simple closure witness: for `a :: xs`, build `xs` first, then join `[a]` with `xs`.\n  classical", "pos": {"x": 0.3606545925140381, "y": 0.5315260291099548}, "pos3": {"x": 0.46290984749794006, "y": 0.5079423189163208, "z": 0.7186169624328613}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.space.mem_U_nil", "name": "HeytingLean.ATheory.Paper.StringPerm.space.mem_U_nil", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 121, "family": "Space", "snippet": "@[simp] lemma mem_U_nil : ([] : List Atom) ∈ (space (Atom := Atom)).U :=\n  spaceRules.mem_U_nil (Atom := Atom) (Allowed := fun _ _ => True)\n\n@[simp] lemma mem_U_singleton (a : Atom) : ([a] : List Atom) ∈ (space (Atom := Atom)).U :=\n  spaceRules.mem_U_singleton (Atom := Atom) (Allowed := fun _ _ => True) a", "pos": {"x": 0.15073958039283752, "y": 0.24886454641819}, "pos3": {"x": 0.2249370962381363, "y": 0.7558214068412781, "z": 0.9780351519584656}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.space.mem_U_singleton", "name": "HeytingLean.ATheory.Paper.StringPerm.space.mem_U_singleton", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 124, "family": "Space", "snippet": "@[simp] lemma mem_U_singleton (a : Atom) : ([a] : List Atom) ∈ (space (Atom := Atom)).U :=\n  spaceRules.mem_U_singleton (Atom := Atom) (Allowed := fun _ _ => True) a\n\nnoncomputable def closed : Closed (space (Atom := Atom)) :=\n  spaceRules.closed_of_total (Atom := Atom) (Allowed := fun _ _ => True) (by intro x y; trivial)", "pos": {"x": 0.05077669769525528, "y": 0.16571973264217377}, "pos3": {"x": 0.12711894512176514, "y": 0.8008354306221008, "z": 0.9482702612876892}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.space.closed", "name": "HeytingLean.ATheory.Paper.StringPerm.space.closed", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 127, "family": "Space", "snippet": "noncomputable def closed : Closed (space (Atom := Atom)) :=\n  spaceRules.closed_of_total (Atom := Atom) (Allowed := fun _ _ => True) (by intro x y; trivial)\n\nend space\n\n/-! ## Flattening syntax objects into strings -/", "pos": {"x": 0.6784700751304626, "y": 0.7756240963935852}, "pos3": {"x": 0.7786616683006287, "y": 0.21642550826072693, "z": 0.47730299830436707}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.flatten", "name": "HeytingLean.ATheory.Paper.StringPerm.flatten", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 134, "family": "Space", "snippet": "def flatten : Obj Atom → List Atom\n  | Obj.base a => [a]\n  | Obj.join l r => flatten l ++ flatten r\n\n@[simp] lemma flatten_base (a : Atom) : flatten (Atom := Atom) (Obj.base a) = [a] := rfl", "pos": {"x": 0.8116721510887146, "y": 0.9160494208335876}, "pos3": {"x": 0.9094122648239136, "y": 0.1914318948984146, "z": 0.3080753982067108}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.flatten_base", "name": "HeytingLean.ATheory.Paper.StringPerm.flatten_base", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 138, "family": "Space", "snippet": "@[simp] lemma flatten_base (a : Atom) : flatten (Atom := Atom) (Obj.base a) = [a] := rfl\n\n@[simp] lemma flatten_join (l r : Obj Atom) :\n    flatten (Atom := Atom) (Obj.join l r) = flatten (Atom := Atom) l ++ flatten (Atom := Atom) r := rfl\n\n/-! ## Mapping ObjSyntax paths to StringPerm paths -/", "pos": {"x": 0.25691163539886475, "y": 0.2975785732269287}, "pos3": {"x": 0.298960417509079, "y": 0.7044122219085693, "z": 0.9692111015319824}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.flatten_join", "name": "HeytingLean.ATheory.Paper.StringPerm.flatten_join", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 140, "family": "Space", "snippet": "@[simp] lemma flatten_join (l r : Obj Atom) :\n    flatten (Atom := Atom) (Obj.join l r) = flatten (Atom := Atom) l ++ flatten (Atom := Atom) r := rfl\n\n/-! ## Mapping ObjSyntax paths to StringPerm paths -/\n\nnamespace ObjSyntaxMap", "pos": {"x": 0.5869554281234741, "y": 0.6773095726966858}, "pos3": {"x": 0.6738150715827942, "y": 0.30822426080703735, "z": 0.5547646284103394}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.mapStep", "name": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.mapStep", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 149, "family": "Space", "snippet": "private def mapStep (s : Step (ObjSyntax.space (Atom := Atom))) :\n    Step (space (Atom := Atom)) :=\n  { x := flatten (Atom := Atom) s.x\n    y := flatten (Atom := Atom) s.y\n    z := flatten (Atom := Atom) s.z\n    ok := by", "pos": {"x": 0.610619306564331, "y": 0.8091549873352051}, "pos3": {"x": 0.7485527992248535, "y": 0.03678038716316223, "z": 0.5303027629852295}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.map_wf_aux", "name": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.map_wf_aux", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 169, "family": "Space", "snippet": "private lemma map_wf_aux (A : Set (Obj Atom)) (A' : Set (List Atom))\n    (hAA' : ∀ t, t ∈ A → flatten (Atom := Atom) t ∈ A') :\n    ∀ {steps : List (Step (ObjSyntax.space (Atom := Atom)))},\n      WellFormedFrom (S := ObjSyntax.space (Atom := Atom)) A steps →\n      WellFormedFrom (S := space (Atom := Atom)) A' (steps.map mapStep) := by\n  intro steps", "pos": {"x": 0.014556940644979477, "y": 0.07137839496135712}, "pos3": {"x": 0.04301278293132782, "y": 1.0, "z": 0.9277289509773254}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.map_wf", "name": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.map_wf", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 194, "family": "Space", "snippet": "private lemma map_wf (p : AssemblyPath (S := ObjSyntax.space (Atom := Atom)) (o : Obj Atom)) :\n    WellFormedFrom (S := space (Atom := Atom)) (space (Atom := Atom)).U (p.steps.map mapStep) := by\n  -- Base mapping property: primitives map to singletons.\n  have hU : ∀ t, t ∈ (ObjSyntax.space (Atom := Atom)).U →\n      flatten (Atom := Atom) t ∈ (space (Atom := Atom)).U := by\n    intro t ht", "pos": {"x": 0.0, "y": 0.0}, "pos3": {"x": 0.0, "y": 0.9576118588447571, "z": 0.9436936974525452}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.map_ok_out", "name": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.map_ok_out", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 206, "family": "Space", "snippet": "private lemma map_ok_out\n    (p : AssemblyPath (S := ObjSyntax.space (Atom := Atom)) (o : Obj Atom)) :\n    ((p.steps.map mapStep) = [] ∧ flatten (Atom := Atom) o ∈ (space (Atom := Atom)).U) ∨\n      (∃ s, (p.steps.map mapStep).getLast? = some s ∧ s.z = flatten (Atom := Atom) o) := by\n  rcases p.ok_out with ⟨hsteps, hoU⟩ | ⟨s, hsLast, hsZ⟩\n  · left", "pos": {"x": 0.06908735632896423, "y": 0.045570723712444305}, "pos3": {"x": 0.041894227266311646, "y": 0.9043743014335632, "z": 0.901749312877655}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.mapPath", "name": "HeytingLean.ATheory.Paper.StringPerm.ObjSyntaxMap.mapPath", "kind": "def", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 231, "family": "Space", "snippet": "noncomputable def mapPath\n    (p : AssemblyPath (S := ObjSyntax.space (Atom := Atom)) (o : Obj Atom)) :\n    AssemblyPath (S := space (Atom := Atom)) (flatten (Atom := Atom) o) :=\n  { steps := p.steps.map mapStep\n    wf := map_wf (Atom := Atom) p\n    ok_out := map_ok_out (Atom := Atom) p }", "pos": {"x": 0.20683683454990387, "y": 0.3429465889930725}, "pos3": {"x": 0.30329808592796326, "y": 0.7513484358787537, "z": 0.8977152109146118}}, {"id": "HeytingLean.ATheory.Paper.StringPerm.assemblyIndex_flatten_le_dagJoinCount", "name": "HeytingLean.ATheory.Paper.StringPerm.assemblyIndex_flatten_le_dagJoinCount", "kind": "lemma", "path": "RESEARCHER_BUNDLE/HeytingLean/ATheory/Paper/StringPermSpace.lean", "line": 242, "family": "Space", "snippet": "lemma assemblyIndex_flatten_le_dagJoinCount [DecidableEq Atom] (o : Obj Atom) :\n    AssemblyIndex.assemblyIndex (S := space (Atom := Atom)) (hC := space.closed (Atom := Atom))\n        (flatten (Atom := Atom) o)\n      ≤ Obj.dagJoinCount o := by\n  classical\n  -- Pick a minimal ObjSyntax path for `o` and map it.", "pos": {"x": 0.10376688092947006, "y": 0.3054605722427368}, "pos3": {"x": 0.1978222131729126, "y": 0.6886477470397949, "z": 0.8660257458686829}}], "edges": [[0, 1], [0, 10], [0, 15], [0, 28], [1, 10], [1, 15], [2, 14], [2, 26], [2, 104], [3, 7], [3, 27], [3, 108], [4, 6], [4, 11], [4, 17], [4, 29], [5, 13], [5, 132], [5, 141], [6, 11], [6, 29], [7, 19], [7, 27], [8, 46], [8, 108], [8, 122], [8, 134], [9, 74], [9, 100], [9, 137], [10, 15], [10, 28], [11, 17], [11, 29], [11, 119], [12, 23], [12, 24], [12, 106], [13, 132], [13, 141], [14, 26], [14, 73], [14, 104], [14, 117], [14, 129], [15, 28], [16, 22], [16, 27], [16, 28], [17, 20], [17, 29], [18, 23], [18, 30], [18, 120], [18, 139], [19, 131], [19, 154], [20, 26], [20, 103], [21, 22], [21, 107], [21, 122], [21, 134], [22, 122], [22, 134], [23, 24], [23, 120], [24, 140], [24, 144], [25, 127], [25, 133], [25, 135], [26, 45], [26, 103], [27, 108], [30, 36], [30, 120], [30, 123], [30, 139], [31, 52], [31, 85], [31, 115], [32, 51], [32, 64], [32, 160], [33, 57], [33, 67], [33, 69], [34, 59], [34, 82], [34, 87], [34, 97], [34, 148], [35, 80], [35, 82], [35, 88], [35, 97], [36, 75], [36, 81], [36, 139], [37, 63], [37, 68], [37, 109], [38, 39], [38, 50], [38, 55], [38, 94], [38, 146], [39, 55], [39, 130], [40, 60], [40, 88], [40, 112], [41, 44], [41, 66], [41, 112], [41, 116], [42, 43], [42, 58], [42, 142], [43, 58], [43, 142], [44, 66], [44, 116], [45, 92], [45, 103], [45, 104], [46, 65], [46, 125], [47, 77], [47, 83], [47, 96], [47, 146], [48, 50], [48, 94], [48, 130], [48, 146], [48, 155], [49, 54], [49, 138], [49, 159], [50, 94], [50, 130], [50, 146], [51, 64], [51, 72], [51, 160], [52, 81], [52, 85], [52, 115], [53, 76], [53, 78], [53, 150], [54, 127], [54, 138], [54, 159], [55, 130], [56, 57], [56, 61], [56, 102], [56, 110], [57, 61], [57, 69], [57, 102], [57, 110], [58, 142], [58, 143], [59, 90], [59, 148], [60, 142], [60, 143], [60, 147], [61, 68], [61, 102], [62, 132], [62, 138], [62, 141], [62, 153], [63, 68], [63, 109], [63, 158], [64, 72], [64, 160], [65, 71], [65, 89], [65, 125], [65, 128], [66, 112], [66, 116], [67, 69], [67, 110], [67, 157], [68, 102], [69, 157], [70, 71], [70, 89], [70, 125], [71, 89], [72, 160], [73, 117], [73, 129], [74, 76], [74, 136], [74, 137], [75, 81], [75, 95], [75, 124], [75, 126], [75, 139], [76, 84], [76, 99], [76, 111], [76, 136], [77, 96], [77, 128], [77, 151], [78, 137], [78, 150], [79, 100], [79, 156], [79, 158], [80, 82], [80, 88], [80, 97], [82, 87], [82, 97], [83, 89], [83, 96], [84, 98], [84, 99], [84, 111], [84, 149], [85, 90], [85, 91], [85, 113], [85, 115], [86, 93], [86, 105], [86, 121], [86, 152], [87, 97], [88, 97], [88, 127], [89, 125], [90, 91], [90, 113], [90, 148], [91, 113], [92, 103], [92, 104], [93, 105], [93, 121], [94, 146], [94, 155], [95, 124], [95, 126], [96, 128], [98, 99], [98, 136], [98, 149], [98, 150], [100, 109], [100, 137], [100, 156], [100, 158], [101, 124], [101, 126], [101, 130], [103, 114], [103, 145], [105, 121], [106, 118], [106, 140], [106, 144], [107, 122], [107, 134], [107, 152], [108, 134], [108, 151], [109, 156], [109, 158], [110, 157], [111, 147], [114, 119], [114, 145], [117, 129], [118, 135], [118, 144], [119, 145], [120, 139], [121, 152], [122, 134], [123, 139], [123, 154], [124, 126], [125, 128], [127, 133], [127, 135], [131, 151], [131, 154], [132, 141], [132, 153], [133, 135], [136, 149], [137, 150], [138, 153], [138, 159], [140, 144], [141, 153], [142, 143], [143, 147], [146, 155], [156, 158]]}
