import Mathlib.Combinatorics.SimpleGraph.Basic
import Mathlib.Combinatorics.SimpleGraph.Maps
import Mathlib.Combinatorics.SimpleGraph.Operations
import Mathlib.Combinatorics.SimpleGraph.Sum

import HeytingLean.ATheory.AssemblyCore
import HeytingLean.ATheory.Paper.AssemblyIndex
import HeytingLean.ATheory.Paper.AssemblyQuotient

namespace HeytingLean
namespace ATheory
namespace Paper

open scoped Classical

/-!
# Molecular assembly (bonds as primitives; vertex identification join)

This file provides a molecular-flavoured Assembly Theory model in two compatible forms:

* **Option A (syntax-first):** work in `ObjSyntax.space` with primitives `Bond Atom`.
  We define an *evaluation semantics* into finite labelled graphs where join corresponds to
  disjoint union + vertex identification (Cronin-style “atom superposition”).

* **Option B (quotient-by-isomorphism):** quotient the syntax space by label-preserving graph
  isomorphism of evaluations using `AssemblySpace.quotient`.

The purpose is to expose the correct join operation (vertex identification) while keeping closure
proofs tractable by working inside the definitional closure generated by the syntax space.
-/

namespace Molecular

universe u
variable {Atom : Type u}

/-! ## Bonds as primitives -/

/-- A bond primitive as a *unique bond instance*.

Cronin-style Molecular Assembly treats *unique bonds in the target molecule* as primitives.
To reflect uniqueness at the type level (so distinct bonds cannot be silently “reused”), we
attach an `id : Nat`.

We keep endpoints ordered for now; a later refinement can quotient by symmetry.
-/
structure Bond (Atom : Type u) where
  id : Nat
  a : Atom
  b : Atom
deriving DecidableEq

/-! ## A finite labelled graph semantics -/

/-
We work with *vertex-labelled* graphs, but we need to remember both:

* atom labels (chemical elements etc.), and
* unique bond identities (since primitives are unique bonds, not bond-types).

Because `SimpleGraph` has no edge labels, we encode each bond instance as a distinguished
**bond vertex** labelled by `Sum.inr bondId`, adjacent to its two endpoint atom vertices.

So a “molecule” becomes a simple graph whose vertex labels live in `Atom ⊕ Nat`.
-/

abbrev MolLabel (Atom : Type u) := Atom ⊕ Nat

/-- A finite labelled simple graph (hydrogen-suppressed), used as a semantics target.

`V` is an abstract finite vertex type; `label` assigns a label in `Atom ⊕ Nat` to each vertex.
The underlying graph is unlabelled.
-/

structure MolGraph (Atom : Type u) where
  V : Type
  [instFintype : Fintype V]
  [instDecEq : DecidableEq V]
  label : V → MolLabel Atom
  graph : SimpleGraph V

attribute [instance] MolGraph.instFintype MolGraph.instDecEq

/-! Label-preserving graph isomorphisms. -/

def MolIso (G H : MolGraph Atom) : Prop :=
  ∃ iso : G.graph ≃g H.graph, ∀ v, H.label (iso v) = G.label v

lemma molIso_refl (G : MolGraph Atom) : MolIso (Atom := Atom) G G := by
  refine ⟨SimpleGraph.Iso.refl (G := G.graph), ?_⟩
  intro v
  simp

lemma molIso_symm {G H : MolGraph Atom} :
    MolIso (Atom := Atom) G H → MolIso (Atom := Atom) H G := by
  rintro ⟨iso, hlabel⟩
  refine ⟨iso.symm, ?_⟩
  intro v
  -- apply `hlabel` at `iso.symm v`
  have := hlabel (iso.symm v)
  simpa using this.symm

lemma molIso_trans {G H K : MolGraph Atom} :
    MolIso (Atom := Atom) G H → MolIso (Atom := Atom) H K → MolIso (Atom := Atom) G K := by
  rintro ⟨iso1, h1⟩ ⟨iso2, h2⟩
  refine ⟨iso1.trans iso2, ?_⟩
  intro v
  have h2' := h2 (iso1 v)
  have h1' := h1 v
  simpa using h2'.trans h1'

/-! ## Disjoint union and identification (superposition)

The Cronin-style join is modeled as:

1. disjoint union of graphs, then
2. identify (merge) one vertex from each component.

We implement identification as `replaceVertex` on the disjoint-union graph, followed by
deleting the redundant vertex via `induce`.
-/

namespace MolGraph

/-- Predicate: a vertex carries an atom label (rather than a bond-id label). -/
def IsAtomVertex (G : MolGraph Atom) (v : G.V) : Prop :=
  ∃ a : Atom, G.label v = Sum.inl a

/-- Predicate: a vertex carries a bond-id label. -/
def IsBondVertex (G : MolGraph Atom) (v : G.V) : Prop :=
  ∃ n : Nat, G.label v = Sum.inr n

def disjointUnion (G H : MolGraph Atom) : MolGraph Atom where
  V := G.V ⊕ H.V
  label := Sum.elim G.label H.label
  graph := G.graph ⊕g H.graph

noncomputable def identify (G H : MolGraph Atom) (v : G.V) (w : H.V) : MolGraph Atom := by
  classical
  let U : MolGraph Atom := disjointUnion (Atom := Atom) G H
  let s : U.V := Sum.inl v
  let t : U.V := Sum.inr w
  -- Make `s` inherit all neighbours of `t`, then delete `t`.
  -- This implements a vertex-identification/merge of `s` and `t` (Cronin “superposition”).
  let merged : SimpleGraph U.V := U.graph ⊔ (U.graph.replaceVertex t s)
  let keep : Set U.V := {x | x ≠ Sum.inr w}
  -- Delete the redundant vertex `t`.
  let G' : SimpleGraph (Subtype keep) := merged.induce keep
  exact
    { V := Subtype keep
      label := fun x => U.label x.1
      graph := G' }

/-- Cronin-style join at the graph level: disjoint union, then superpose two **atom vertices**.

We keep this as a predicate (rather than a deterministic function) to reflect the nondeterminism
of choosing which atoms to superpose.
-/
def IsJoinAtom (G H K : MolGraph Atom) : Prop :=
  ∃ (v : G.V) (w : H.V),
    IsAtomVertex (Atom := Atom) G v ∧
    IsAtomVertex (Atom := Atom) H w ∧
    MolIso (Atom := Atom) K (identify (Atom := Atom) G H v w)

end MolGraph

/-! ## Evaluation from bond syntax

We evaluate an `Obj (Bond Atom)` (syntax tree) into a graph by identifying one vertex at each join.

To keep this deterministic without extra annotations, we maintain a distinguished *port* vertex.
At each join, we superpose the left port with the right port.
-/

structure MolState (Atom : Type u) where
  core : MolGraph Atom
  port : core.V

namespace MolState

def disjointUnion (G H : MolState Atom) : MolState Atom where
  core := MolGraph.disjointUnion (Atom := Atom) G.core H.core
  port := Sum.inl G.port

noncomputable def join (G H : MolState Atom) : MolState Atom := by
  classical
  -- Identify left port with right port.
  let core' := MolGraph.identify (Atom := Atom) G.core H.core G.port H.port
  exact
    { core := core'
      port := ⟨Sum.inl G.port, by
        intro h
        cases h⟩ }

end MolState

def evalBond (b : Bond Atom) : MolState Atom := by
  classical
  -- Encode a *unique bond* inside `SimpleGraph` by introducing an explicit bond-vertex.
  -- Vertices are labelled by `Atom ⊕ Nat`, where `Sum.inr b.id` tags the bond instance.
  let Label := Atom ⊕ Nat
  let V : Type := Fin 3
  let vA : V := ⟨0, by decide⟩
  let vB : V := ⟨1, by decide⟩
  let vBond : V := ⟨2, by decide⟩
  let label : V → Label := fun v =>
    match v.1 with
    | 0 => Sum.inl b.a
    | 1 => Sum.inl b.b
    | _ => Sum.inr b.id
  let g : SimpleGraph V :=
    SimpleGraph.edge vBond vA ⊔ SimpleGraph.edge vBond vB
  exact
    { core := { V := V, label := label, graph := g }
      port := vA }

noncomputable def evalObj : Obj (Bond Atom) → MolState Atom
  | Obj.base b => evalBond (Atom := Atom) b
  | Obj.join x y => MolState.join (Atom := Atom) (evalObj x) (evalObj y)

noncomputable def evalCore (o : Obj (Bond Atom)) : MolGraph Atom :=
  (evalObj (Atom := Atom) o).core

/-! ## Option B: quotient-by-isomorphism space -/

def evalIsoRel (x y : Obj (Bond Atom)) : Prop :=
  MolIso (Atom := Atom) (evalCore (Atom := Atom) x) (evalCore (Atom := Atom) y)

private theorem evalIsoRel_refl (x : Obj (Bond Atom)) : evalIsoRel (Atom := Atom) x x :=
  molIso_refl (Atom := Atom) (evalCore (Atom := Atom) x)

private theorem evalIsoRel_symm {x y : Obj (Bond Atom)} :
    evalIsoRel (Atom := Atom) x y → evalIsoRel (Atom := Atom) y x := by
  exact molIso_symm (Atom := Atom)

private theorem evalIsoRel_trans {x y z : Obj (Bond Atom)} :
    evalIsoRel (Atom := Atom) x y → evalIsoRel (Atom := Atom) y z → evalIsoRel (Atom := Atom) x z := by
  exact molIso_trans (Atom := Atom)

def evalIsoSetoid : Setoid (Obj (Bond Atom)) :=
  Setoid.mk (evalIsoRel (Atom := Atom))
    ⟨evalIsoRel_refl (Atom := Atom),
     by intro x y; exact evalIsoRel_symm (Atom := Atom),
     by intro x y z; exact evalIsoRel_trans (Atom := Atom)⟩

/-- The molecular assembly space as a quotient of the bond syntax space.

This is a direct use of Extension 2 (quotient assembly spaces).
-/
def molSpace (Atom : Type u) : AssemblySpace :=
  AssemblySpace.quotient
    (S := ObjSyntax.space (Atom := Bond Atom))
    (evalIsoSetoid (Atom := Atom))

noncomputable def closed (Atom : Type u) : AssemblySpace.Closed (molSpace (Atom := Atom)) := by
  simpa [molSpace] using
    (AssemblySpace.Closed.quotient
      (S := ObjSyntax.space (Atom := Bond Atom))
      (ObjSyntax.space.closed (Atom := Bond Atom))
      (evalIsoSetoid (Atom := Atom)))

/-! ## Two proof routes (Option A and Option B)

We provide two formally valid proof routes for an index bound:

* Option A: inside the syntax space, `assemblyIndex = dagJoinCount`.
* Option B: in the quotient (molecular) space, `assemblyIndex ≤ dagJoinCount` for any representative.
-/

lemma assemblyIndex_syntax_eq_dagJoinCount [DecidableEq Atom] (o : Obj (Bond Atom)) :
    AssemblySpace.AssemblyIndex.assemblyIndex
        (S := ObjSyntax.space (Atom := Bond Atom))
        (hC := ObjSyntax.space.closed (Atom := Bond Atom)) o
      = Obj.dagJoinCount o := by
  simpa using
    (ObjSyntax.space.assemblyIndex_eq_dagJoinCount (Atom := Bond Atom) (o := o))

lemma assemblyIndex_mol_le_dagJoinCount [DecidableEq Atom] (o : Obj (Bond Atom)) :
    AssemblySpace.AssemblyIndex.assemblyIndex
        (S := molSpace (Atom := Atom))
        (hC := closed (Atom := Atom))
        (Quotient.mk (evalIsoSetoid (Atom := Atom)) o)
      ≤ Obj.dagJoinCount o := by
  classical
  -- Use the generic quotient bound, then the syntax equality.
  have hq :
      AssemblySpace.AssemblyIndex.assemblyIndex
          (S := molSpace (Atom := Atom))
          (hC := closed (Atom := Atom))
          (Quotient.mk (evalIsoSetoid (Atom := Atom)) o)
        ≤
        AssemblySpace.AssemblyIndex.assemblyIndex
          (S := ObjSyntax.space (Atom := Bond Atom))
          (hC := ObjSyntax.space.closed (Atom := Bond Atom)) o :=
    AssemblySpace.AssemblyIndex.assemblyIndex_quotient_le
      (S := ObjSyntax.space (Atom := Bond Atom))
      (hC := ObjSyntax.space.closed (Atom := Bond Atom))
      (r := evalIsoSetoid (Atom := Atom))
      (z := o)
  simpa [assemblyIndex_syntax_eq_dagJoinCount (Atom := Atom) (o := o)] using hq

end Molecular

end Paper
end ATheory
end HeytingLean
